{"version":3,"sources":["styles.module.scss","hooks/useMousetrap.ts","utils/createPageMapCoordsToContainer.ts","utils/cellToDate.ts","utils/createMapCellInfoToRecurringTimeRange.ts","utils/getSpan.ts","utils/createMapDateRangeToCells.ts","utils/createGridFromContainer.ts","utils/mergeEvents.ts","index.tsx","hooks/useClickAndDrag.ts"],"names":["module","exports","root","timeline","debug","debug-active","calendar","react-draggable","handle-wrapper","handle","top","bottom","layer-container","event","drag-box","draggable","button-reset","is-draggable","react-draggable-dragging","is-pending-creation","hours-container","day-column","day-hours","cell","time","title","header","first","popup","range-boxes","event-content","start","end","weakMap","WeakMap","useMousetrap","handlerKey","handlerCallback","element","actionRef","useRef","current","useEffect","instance","get","Mousetrap","set","bind","mousetrap","unbind","createPageMapCoordsToContainer","container","clientX","clientY","pageX","pageY","_event$changedTouches","changedTouches","_container$getBoundin","getBoundingClientRect","left","x","y","createMapCellInfoToRecurringTimeRange","_ref","toMin","fromY","toDay","fromX","originDate","_ref2","startX","startY","endX","spanY","range","map","i","startDate","addMinutes","addDays","cellToDate","endDate","isEqual","startOfDay","endOfDay","subDays","isBefore","sort","rangeA","rangeB","getSpan","x1","x2","Math","abs","createMapDateRangeToCells","_ref$toX","toX","toY","numVerticalCells","_ref3","Object","slicedToArray","originOfThisDay","_startX","differenceInDays","_startY","differenceInMinutes","_endX","_endY","cells","endY","spanX","pop","createGridForContainer","totalHeight","totalWidth","numHorizontalCells","cellWidth","cellHeight","getRectFromCell","data","this","right","height","width","getCellFromRect","clamp","floor","round","mergeRanges","_mergeRanges","toConsumableArray","d","c","Date","mergeEvents","event1","event2","concat","range1","range2","compareAsc","defaultSchedule","RangeBox","grid","isBeingEdited","rangeIndex","cellIndex","cellArray","className","onChange","cellInfoToDateRange","isResizable","isDeletable","isMovable","ref","_useState","useState","_useState2","modifiedCell","setModifiedCell","originalRect","useMemo","rect","modifiedDateRange","useCallback","undefined","style","isStart","isEnd","length","handleStop","newCell","objectSpread","handleDrag","_event","_start","_end","newTop","min","newBottom","newRect","_grid$getCellFromRect","invariant","handleResize","direction","delta","newSize","includes","_grid$getCellFromRect2","react_default","a","createElement","react_draggable_default","axis","bounds","position","onDrag","onStop","cancel","classes","cc","defineProperty","tabIndex","lib","size","onResize","onResizeStop","handleWrapperClass","enable","handleClasses","bottomLeft","bottomRight","topLeft","topRight","format","Schedule","_ref4","ranges","dateRangeToCells","dateRange","key","array","MINS_IN_DAY","horizontalPrecision","days","rootElement","document","getElementById","ReactDOM","render","_ref5","_ref5$verticalPrecisi","verticalPrecision","_ref5$visualGridPreci","visualGridPrecision","visualGridVerticalPrecision","startOfWeek","weekStartsOn","mins","cellInfoToDateRanges","cellInfoToSingleDateRange","_cellInfoToDateRanges","_cellInfoToDateRanges2","toArray","rest","slice","parent","useComponentSize","_useClickAndDrag","setStyle","_useState3","_useState4","box","setBox","_useState5","_useState6","isDragging","setIsDragging","_useState7","_useState8","hasFinishedDragging","setHasFinishedDragging","mapCoordsToContainer","touchStart$","fromEvent","passive","touchMove$","window","touchEnd$","mouseDown$","pipe","filter","which","mouseMove$","mouseUp$","dragStart$","merge","tap","e","stopPropagation","preventDefault","dragEnd$","move$","box$","mergeMap","down","startWith","move","max","scrollWidth","scrollHeight","takeUntil","distinctUntilChanged","style$","boxSubscriber","subscribe","styleSubscriber","unsubscribe","useClickAndDrag","pendingCreation","setPendingCreation","_useUndo","useUndo","dateString","_useUndo2","scheduleState","_useUndo2$","setSchedule","undoSchedule","undo","redoSchedule","redo","canUndoSchedule","canUndo","canRedoSchedule","canRedo","_useMemo","_parent$current","constrainedBox","dateRanges","present","handleEventChange","newDateRange","newSchedule","splice","getDateRangeForVisualGrid","contains","activeElement","scrollIntoView","scrollMode","block","inline","times","timeIndex","startText","_getDateRangeForVisua","_getDateRangeForVisua2","dayIndex"],"mappings":"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","file":"static/js/main.eb203e97.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"styles_root__3QAxj\",\"timeline\":\"styles_timeline__106Mk\",\"debug\":\"styles_debug__2SKKM\",\"debug-active\":\"styles_debug-active___9OUc\",\"calendar\":\"styles_calendar__3Xx2Y\",\"react-draggable\":\"styles_react-draggable__2QRVw\",\"handle-wrapper\":\"styles_handle-wrapper__2T7f7\",\"handle\":\"styles_handle__1dKGL\",\"top\":\"styles_top__2FFal\",\"bottom\":\"styles_bottom__3nd0X\",\"layer-container\":\"styles_layer-container__1Quoi\",\"event\":\"styles_event__bjik1\",\"drag-box\":\"styles_drag-box__OvX9t\",\"draggable\":\"styles_draggable__a1ktL\",\"button-reset\":\"styles_button-reset__3_zQt\",\"is-draggable\":\"styles_is-draggable__2U2x2\",\"react-draggable-dragging\":\"styles_react-draggable-dragging__1T3s8\",\"is-pending-creation\":\"styles_is-pending-creation__2vDDI\",\"hours-container\":\"styles_hours-container__3XZzL\",\"day-column\":\"styles_day-column__2sQzS\",\"day-hours\":\"styles_day-hours__3_7p4\",\"cell\":\"styles_cell__1OJUD\",\"time\":\"styles_time__1X-Hn\",\"title\":\"styles_title__2dKTz\",\"header\":\"styles_header__1IF59\",\"first\":\"styles_first__1t63n\",\"popup\":\"styles_popup__2oSt1\",\"range-boxes\":\"styles_range-boxes__39XBE\",\"event-content\":\"styles_event-content__1EBie\",\"start\":\"styles_start__2DXVx\",\"end\":\"styles_end__2XnIt\"};","import mousetrap from 'mousetrap';\nimport { useEffect, useRef } from 'react';\n\nconst weakMap = new WeakMap<typeof document | Element, MousetrapInstance>();\n\n/**\n * Use mousetrap hook\n *\n * @param handlerKey - A key, key combo or array of combos according to Mousetrap documentation.\n * @param  handlerCallback - A function that is triggered on key combo catch.\n */\nexport default function useMousetrap(\n  handlerKey: string | string[],\n  handlerCallback: () => void,\n  element: typeof document | Element | null\n) {\n  const actionRef = useRef<typeof handlerCallback | null>(null);\n  actionRef.current = handlerCallback;\n\n  useEffect(() => {\n    if (!element) {\n      return;\n    }\n\n    let instance = weakMap.get(element);\n\n    if (!instance) {\n      instance = new Mousetrap(element as Element);\n      weakMap.set(element, instance);\n    }\n\n    instance.bind(handlerKey, () => {\n      typeof actionRef.current === 'function' && actionRef.current();\n    });\n\n    return () => {\n      mousetrap.unbind(handlerKey);\n    };\n  }, [handlerKey, element]);\n}\n","export const createPageMapCoordsToContainer = (container: HTMLElement) => {\n  return (event: React.MouseEvent | MouseEvent | TouchEvent) => {\n    let clientX: number;\n    let clientY: number;\n    let pageX: number;\n    let pageY: number;\n\n    if ('changedTouches' in event) {\n      ({ clientX, clientY, pageX, pageY } = event.changedTouches[0]);\n    } else {\n      ({ clientX, clientY, pageX, pageY } = event);\n    }\n    const { top, left } = container.getBoundingClientRect();\n\n    return {\n      clientX,\n      clientY,\n      pageX,\n      pageY,\n      top,\n      left,\n      x: clientX - left,\n      y: clientY - top\n    };\n  };\n};\n","import { addMinutes, addDays } from 'date-fns';\n\nexport const cellToDate = ({\n  startX,\n  startY,\n  toMin,\n  originDate\n}: {\n  startX: number;\n  startY: number;\n  toMin: (y: number) => number;\n  toDay: (x: number) => number;\n  originDate: Date;\n}) => addMinutes(addDays(originDate, startX), toMin(startY));\n","import { DateRange, MapCellInfoToDateRange } from '../types';\nimport { range } from 'lodash';\nimport {\n  addMinutes,\n  isBefore,\n  endOfDay,\n  isEqual,\n  subDays,\n  startOfDay\n} from 'date-fns';\nimport { cellToDate } from './cellToDate';\n\nexport type RecurringTimeRange = DateRange[];\n\nexport const createMapCellInfoToRecurringTimeRange: MapCellInfoToDateRange = ({\n  fromY: toMin,\n  fromX: toDay,\n  originDate\n}) => ({ startX, startY, endX, spanY }) => {\n  const result = range(startX, endX + 1)\n    .map(i => {\n      const startDate = cellToDate({\n        startX: i,\n        startY,\n        toMin,\n        toDay,\n        originDate\n      });\n      let endDate = addMinutes(startDate, toMin(spanY));\n\n      if (isEqual(endDate, startOfDay(endDate))) {\n        endDate = endOfDay(subDays(endDate, 1));\n      }\n\n      const range: DateRange = isBefore(startDate, endDate)\n        ? [startDate, endDate]\n        : [endDate, startDate];\n\n      return range;\n    })\n    .sort((rangeA, rangeB) => (isBefore(rangeA[0], rangeB[0]) ? 0 : 1));\n\n  return result;\n};\n","export const getSpan = (x1: number, x2: number) => 1 + Math.abs(x2 - x1);\n","import { DateRange, CellInfo } from '../types';\nimport {\n  startOfDay,\n  differenceInDays,\n  differenceInMinutes,\n  isEqual\n} from 'date-fns';\nimport { range } from 'lodash';\nimport { getSpan } from './getSpan';\n\nexport const createMapDateRangeToCells = ({\n  toX = (x: number) => x,\n  toY,\n  numVerticalCells,\n  originDate\n}: {\n  toX: (day: number) => number;\n  toY: (min: number) => number;\n  numHorizontalCells: number;\n  numVerticalCells: number;\n  originDate: Date;\n}) => ([start, end]: DateRange): CellInfo[] => {\n  const originOfThisDay = startOfDay(start);\n  const _startX = toX(differenceInDays(start, originDate));\n  const _startY = toY(differenceInMinutes(start, originOfThisDay));\n  const _endX = toX(differenceInDays(end, originDate));\n  const _endY = toY(differenceInMinutes(end, startOfDay(end))) - 1;\n\n  const cells = range(_startX, _endX + 1).map(i => {\n    const startX = i;\n    const endX = i;\n    const atStart = i === _startX;\n    const atEnd = i === _endX;\n    const startY = !atStart ? 0 : _startY;\n    const endY = !atEnd ? numVerticalCells - 1 : _endY;\n    const spanX = getSpan(startX, endX);\n    const spanY = getSpan(startY, endY);\n\n    return {\n      startX,\n      startY,\n      endX,\n      endY,\n      spanX,\n      spanY\n    };\n  });\n\n  if (isEqual(end, startOfDay(end))) {\n    cells.pop();\n  }\n\n  return cells;\n};\n","import { Grid, CellInfo, Rect } from '../types';\nimport { clamp, floor, round } from 'lodash';\nimport { getSpan } from './getSpan';\n\nexport const createGridForContainer = ({\n  totalHeight,\n  totalWidth,\n  numVerticalCells,\n  numHorizontalCells\n}: {\n  totalHeight: number;\n  totalWidth: number;\n  numVerticalCells: number;\n  numHorizontalCells: number;\n}): Grid => {\n  const cellHeight = totalHeight / numVerticalCells;\n  const cellWidth = totalWidth / numHorizontalCells;\n\n  return {\n    totalHeight,\n    totalWidth,\n    numVerticalCells,\n    numHorizontalCells,\n    cellWidth,\n    cellHeight,\n\n    getRectFromCell(data: CellInfo) {\n      const { endX, startX, endY, startY, spanX, spanY } = data;\n      const bottom = endY * this.cellHeight;\n      const top = startY * this.cellHeight;\n      const left = startX * this.cellWidth;\n      const right = endX * this.cellWidth;\n      const height = spanY * this.cellHeight;\n      const width = spanX * this.cellWidth;\n\n      return {\n        bottom,\n        top,\n        left,\n        right,\n        height,\n        width,\n\n        // @TODO: check the math\n        startX: startX * this.cellWidth,\n        endX: endX * this.cellWidth,\n        startY: startY * this.cellHeight,\n        endY: endY * this.cellHeight\n      };\n    },\n\n    getCellFromRect(data: Rect) {\n      const startX = clamp(\n        floor(data.left / this.cellWidth),\n        0,\n        numHorizontalCells - 1\n      );\n      const startY = clamp(\n        round(data.top / this.cellHeight),\n        0,\n        numVerticalCells - 1\n      );\n      const endX = clamp(\n        floor(data.right / this.cellWidth),\n        0,\n        numHorizontalCells - 1\n      );\n      const endY = clamp(\n        round(data.bottom / this.cellHeight),\n        0,\n        numVerticalCells - 1\n      );\n      const spanX = clamp(getSpan(startX, endX), 1, numHorizontalCells);\n      const spanY = clamp(getSpan(startY, endY), 1, numVerticalCells);\n\n      return {\n        spanX,\n        spanY,\n        startX,\n        startY,\n        endX,\n        endY\n      };\n    }\n  };\n};\n","import { Event } from '../types';\n// @ts-ignore\nimport _mergeRanges from 'merge-ranges';\nimport { compareAsc } from 'date-fns';\n\nexport function mergeRanges(event: Event): Event {\n  return _mergeRanges([...event].map(d => d.map(c => new Date(c))));\n}\n\nexport function mergeEvents(event1: Event, event2: Event | null): Event {\n  if (event2 === null) {\n    return event1;\n  }\n\n  return mergeRanges([...event1, ...event2]).sort((range1, range2) =>\n    compareAsc(range1[0], range2[0])\n  );\n}\n","import 'resize-observer-polyfill/dist/ResizeObserver.global';\n\nimport React, {\n  useRef,\n  useState,\n  useMemo,\n  useCallback,\n  useEffect\n} from 'react';\nimport ReactDOM from 'react-dom';\nimport invariant from 'invariant';\nimport { times } from 'lodash';\nimport { format, startOfWeek, addDays, compareAsc } from 'date-fns';\nimport useComponentSize from '@rehooks/component-size';\nimport useUndo from 'use-undo';\nimport scrollIntoView from 'scroll-into-view-if-needed';\nimport useMousetrap from './hooks/useMousetrap';\nimport cc from 'classcat';\nimport Resizable, { ResizeCallback } from 're-resizable';\nimport Draggable, { DraggableEventHandler } from 'react-draggable';\n\nimport { Grid, Event as CalendarEvent, CellInfo, DateRange } from './types';\n\nimport { useClickAndDrag } from './hooks/useClickAndDrag';\nimport {\n  createMapCellInfoToRecurringTimeRange,\n  RecurringTimeRange\n} from './utils/createMapCellInfoToRecurringTimeRange';\nimport { createMapDateRangeToCells } from './utils/createMapDateRangeToCells';\nimport { createGridForContainer } from './utils/createGridFromContainer';\nimport { mergeEvents, mergeRanges } from './utils/mergeEvents';\n\nimport classes from './styles.module.scss';\n\nconst defaultSchedule: [string, string][] = [\n  ['2019-03-03T22:45:00.000Z', '2019-03-04T01:15:00.000Z'],\n  ['2019-03-05T22:00:00.000Z', '2019-03-06T01:00:00.000Z'],\n  ['2019-03-04T22:15:00.000Z', '2019-03-05T01:00:00.000Z'],\n  ['2019-03-07T05:30:00.000Z', '2019-03-07T10:00:00.000Z'],\n  ['2019-03-08T22:00:00.000Z', '2019-03-09T01:00:00.000Z'],\n  ['2019-03-09T22:00:00.000Z', '2019-03-10T01:00:00.000Z'],\n  ['2019-03-06T22:00:00.000Z', '2019-03-07T01:00:00.000Z']\n];\n\ntype OnChangeCallback = (\n  newDateRange: DateRange | undefined,\n  rangeIndex: number\n) => void;\n\nfunction RangeBox({\n  grid,\n  isBeingEdited,\n  rangeIndex,\n  cellIndex,\n  cellArray,\n  cell,\n  className,\n  onChange,\n  cellInfoToDateRange,\n  isResizable,\n  isDeletable,\n  isMovable\n}: {\n  grid: Grid;\n  cell: CellInfo;\n  cellIndex: number;\n  cellArray: CellInfo[];\n  className?: string;\n  onChange?: OnChangeCallback;\n  isResizable?: boolean;\n  isDeletable?: boolean;\n  isMovable?: boolean;\n  rangeIndex: number;\n  isBeingEdited?(cell: CellInfo): boolean;\n  cellInfoToDateRange(cell: CellInfo): DateRange;\n}) {\n  const ref = useRef(null);\n  const [modifiedCell, setModifiedCell] = useState(cell);\n  const originalRect = useMemo(() => grid.getRectFromCell(cell), [cell, grid]);\n  const rect = useMemo(() => grid.getRectFromCell(modifiedCell), [\n    modifiedCell,\n    grid\n  ]);\n\n  useEffect(() => {\n    setModifiedCell(cell);\n  }, [cell]);\n\n  const modifiedDateRange = useMemo(() => cellInfoToDateRange(modifiedCell), [\n    modifiedCell\n  ]);\n\n  const handleDelete = useCallback(() => {\n    if (!isDeletable) {\n      return;\n    }\n\n    onChange && onChange(undefined, rangeIndex);\n  }, [ref.current, onChange, isDeletable, rangeIndex]);\n\n  useMousetrap('del', handleDelete, ref.current);\n\n  const { top, left, width, height } = rect;\n\n  const style = { width, height };\n\n  const isStart = cellIndex === 0;\n  const isEnd = cellIndex === cellArray.length - 1;\n\n  const handleStop = useCallback(() => {\n    onChange && onChange(cellInfoToDateRange(modifiedCell), rangeIndex);\n  }, [modifiedCell, rangeIndex, cellInfoToDateRange, onChange]);\n\n  useMousetrap(\n    'up',\n    () => {\n      if (!isMovable) {\n        return;\n      }\n\n      if (modifiedCell.startY === 0) {\n        return;\n      }\n\n      const newCell = {\n        ...modifiedCell,\n        startY: modifiedCell.startY - 1,\n        endY: modifiedCell.endY - 1\n      };\n\n      onChange && onChange(cellInfoToDateRange(newCell), rangeIndex);\n    },\n    ref.current\n  );\n\n  useMousetrap(\n    'down',\n    () => {\n      if (!isMovable) {\n        return;\n      }\n\n      if (modifiedCell.endY === grid.numVerticalCells - 1) {\n        return;\n      }\n\n      const newCell = {\n        ...modifiedCell,\n        startY: modifiedCell.startY + 1,\n        endY: modifiedCell.endY + 1\n      };\n\n      onChange && onChange(cellInfoToDateRange(newCell), rangeIndex);\n    },\n    ref.current\n  );\n\n  const handleDrag: DraggableEventHandler = useCallback(\n    (_event, { y }) => {\n      if (!isMovable) {\n        return;\n      }\n\n      const _start = y;\n      const _end = _start + rect.height;\n      const newTop = Math.min(_start, _end);\n      const newBottom = newTop + rect.height;\n\n      if (newTop === top) {\n        return;\n      }\n\n      const newRect = {\n        ...rect,\n        top: newTop,\n        bottom: newBottom\n      };\n\n      const { startY, endY } = grid.getCellFromRect(newRect);\n\n      const newCell = {\n        ...cell,\n        startY,\n        endY\n      };\n\n      invariant(\n        newCell.spanY === cell.spanY,\n        `Expected the dragged time cell to have the same height (${\n          newCell.spanY\n        }, ${cell.spanY})`\n      );\n      setModifiedCell(newCell);\n    },\n    [grid, rect, isMovable, setModifiedCell]\n  );\n\n  const handleResize: ResizeCallback = useCallback(\n    (_event, direction, _ref, delta) => {\n      if (!isResizable) {\n        return;\n      }\n\n      if (delta.height === 0) {\n        return;\n      }\n\n      const newSize = {\n        height: delta.height + rect.height,\n        width: delta.width + rect.width\n      };\n\n      const newRect = {\n        ...originalRect,\n        ...newSize\n      };\n\n      if (direction.includes('top')) {\n        newRect.top -= delta.height;\n      } else if (direction.includes('bottom')) {\n        newRect.bottom += delta.height;\n      }\n\n      const { spanY, startY, endY } = grid.getCellFromRect(newRect);\n      const newCell = {\n        ...cell,\n        spanY,\n        startY,\n        endY\n      };\n\n      setModifiedCell(newCell);\n    },\n    [grid, rect, isResizable, setModifiedCell, originalRect]\n  );\n\n  return (\n    <Draggable\n      axis={isMovable ? 'y' : 'none'}\n      bounds={{\n        top: 0,\n        bottom: grid.totalHeight - height,\n        left: 0,\n        right: grid.totalWidth\n      }}\n      position={{ x: left, y: top }}\n      onDrag={handleDrag}\n      onStop={handleStop}\n      cancel={`.${classes.handle}`}\n    >\n      <button\n        className={cc([\n          classes['event'],\n          classes['button-reset'],\n          classes['range-box'],\n          className,\n          {\n            [classes['is-draggable']]: isMovable,\n            [classes['is-being-edited']]: isBeingEdited && isBeingEdited(cell)\n          }\n        ])}\n        ref={ref}\n        tabIndex={0}\n        style={style}\n      >\n        <Resizable\n          size={originalRect}\n          onResize={handleResize}\n          onResizeStop={handleStop}\n          handleWrapperClass={classes['handle-wrapper']}\n          enable={\n            isResizable\n              ? {\n                  top: true,\n                  bottom: true\n                }\n              : {}\n          }\n          handleClasses={{\n            bottom: cc([classes['handle'], classes.bottom]),\n            bottomLeft: cc([classes['handle'], classes['bottom-left']]),\n            bottomRight: cc([classes['handle'], classes['bottom-right']]),\n            left: cc([classes['handle'], classes.left]),\n            right: cc([classes['handle'], classes.right]),\n            top: cc([classes['handle'], classes.top]),\n            topLeft: cc([classes['handle'], classes['top-left']]),\n            topRight: cc([classes['handle'], classes['top-right']])\n          }}\n        >\n          <div className={classes['event-content']} style={style}>\n            <span className={classes['start']}>\n              {isStart && format(modifiedDateRange[0], 'h:mma')}\n            </span>\n            <span className={classes['end']}>\n              {isEnd && format(modifiedDateRange[1], 'h:mma')}\n            </span>\n          </div>\n        </Resizable>\n      </button>\n    </Draggable>\n  );\n}\n\nfunction Schedule({\n  ranges,\n  grid,\n  className,\n  onChange,\n  isResizable,\n  isDeletable,\n  isMovable,\n  cellInfoToDateRange,\n  dateRangeToCells,\n  isBeingEdited\n}: {\n  ranges: CalendarEvent;\n  grid: Grid;\n  className?: string;\n  isResizable?: boolean;\n  isDeletable?: boolean;\n  isMovable?: boolean;\n  onChange?: OnChangeCallback;\n  dateRangeToCells(range: DateRange): CellInfo[];\n  isBeingEdited?(cell: CellInfo): boolean;\n  cellInfoToDateRange(cell: CellInfo): DateRange;\n}) {\n  return (\n    <div className={classes['range-boxes']}>\n      {ranges.map((dateRange, rangeIndex) => {\n        return (\n          <span key={rangeIndex}>\n            {dateRangeToCells(dateRange).map((cell, cellIndex, array) => {\n              return (\n                <RangeBox\n                  key={cellIndex}\n                  isResizable={isResizable}\n                  isMovable={isMovable}\n                  isDeletable={isDeletable}\n                  cellInfoToDateRange={cellInfoToDateRange}\n                  cellArray={array}\n                  cellIndex={cellIndex}\n                  rangeIndex={rangeIndex}\n                  className={className}\n                  isBeingEdited={isBeingEdited}\n                  onChange={onChange}\n                  grid={grid}\n                  cell={cell}\n                />\n              );\n            })}\n          </span>\n        );\n      })}\n    </div>\n  );\n}\n\nconst MINS_IN_DAY = 24 * 60;\nconst horizontalPrecision = 1;\nconst toDay = (x: number) => x / horizontalPrecision;\nconst toX = (days: number) => days * horizontalPrecision;\n\nfunction App({\n  verticalPrecision = 1 / 30,\n  visualGridPrecision: visualGridVerticalPrecision = 1 / 30\n}) {\n  const originDate = startOfWeek(new Date('2019-03-04'), { weekStartsOn: 1 });\n\n  const numVerticalCells = MINS_IN_DAY * verticalPrecision;\n  const numHorizontalCells = 7 * horizontalPrecision;\n  const toMin = useCallback((y: number) => y / verticalPrecision, [\n    verticalPrecision\n  ]);\n  const toY = (mins: number) => mins * verticalPrecision;\n\n  const cellInfoToDateRanges = useMemo(\n    () =>\n      createMapCellInfoToRecurringTimeRange({\n        originDate,\n        fromY: toMin,\n        fromX: toDay\n      }),\n    [toMin, toDay]\n  );\n\n  const cellInfoToSingleDateRange = useCallback(\n    (cell: CellInfo): DateRange => {\n      const [first, ...rest] = cellInfoToDateRanges(cell);\n\n      invariant(\n        rest.length === 0,\n        `Expected \"cellInfoToSingleDateRange\" to return a single date range, found ${\n          rest.length\n        } additional ranges instead. This is a bug in @remotelock/weekly-scheduler`\n      );\n\n      return first;\n    },\n    [cellInfoToDateRanges]\n  );\n\n  const dateRangeToCells = useCallback(\n    createMapDateRangeToCells({\n      originDate,\n      numVerticalCells,\n      numHorizontalCells,\n      toX,\n      toY\n    }),\n    [toY, toX, numVerticalCells, numHorizontalCells, originDate]\n  );\n\n  const root = useRef<HTMLDivElement | null>(null);\n  const parent = useRef<HTMLDivElement | null>(null);\n\n  const size = useComponentSize(parent);\n  const {\n    style,\n    box,\n    isDragging,\n    hasFinishedDragging,\n    cancel\n  } = useClickAndDrag(parent);\n  const [\n    pendingCreation,\n    setPendingCreation\n  ] = useState<RecurringTimeRange | null>(null);\n  const [\n    scheduleState,\n    {\n      set: setSchedule,\n      undo: undoSchedule,\n      redo: redoSchedule,\n      canUndo: canUndoSchedule,\n      canRedo: canRedoSchedule\n    }\n  ] = useUndo<CalendarEvent>(\n    defaultSchedule\n      .map(\n        range => range.map(dateString => new Date(dateString)) as [Date, Date]\n      )\n      .sort((range1, range2) => compareAsc(range1[0], range2[0]))\n  );\n\n  const { totalHeight, totalWidth } = useMemo(() => {\n    let totalHeight: number | null = null;\n    let totalWidth: number | null = null;\n    if (parent.current !== null) {\n      ({ scrollHeight: totalHeight, scrollWidth: totalWidth } = parent.current);\n    }\n\n    return { totalHeight, totalWidth };\n  }, [parent.current, size]);\n\n  const grid = useMemo<Grid | null>(() => {\n    if (totalHeight === null || totalWidth === null) {\n      return null;\n    }\n\n    return createGridForContainer({\n      totalHeight,\n      totalWidth,\n      numHorizontalCells,\n      numVerticalCells\n    });\n  }, [totalHeight, totalWidth, numHorizontalCells, numVerticalCells]);\n\n  useEffect(() => {\n    if (grid === null || box === null) {\n      setPendingCreation(null);\n      return;\n    }\n\n    const constrainedBox = box;\n    const cell = grid.getCellFromRect(constrainedBox);\n    const dateRanges = cellInfoToDateRanges(cell);\n    const event = dateRanges;\n    setPendingCreation(event);\n  }, [box, grid, setPendingCreation]);\n\n  useEffect(() => {\n    if (hasFinishedDragging) {\n      setSchedule(mergeEvents(scheduleState.present, pendingCreation));\n      setPendingCreation(null);\n    }\n  }, [\n    hasFinishedDragging,\n    setSchedule,\n    setPendingCreation,\n    pendingCreation,\n    scheduleState.present\n  ]);\n\n  useMousetrap(\n    'ctrl+z',\n    () => {\n      if (!canUndoSchedule) {\n        return;\n      }\n\n      undoSchedule();\n    },\n    document\n  );\n\n  useMousetrap(\n    'ctrl+shift+z',\n    () => {\n      if (!canRedoSchedule) {\n        return;\n      }\n\n      redoSchedule();\n    },\n    document\n  );\n\n  useMousetrap(\n    'esc',\n    () => {\n      if (pendingCreation) {\n        cancel();\n      }\n    },\n    document\n  );\n\n  useEffect(() => {\n    cancel();\n  }, [size]);\n\n  const handleEventChange = useCallback<OnChangeCallback>(\n    (newDateRange, rangeIndex) => {\n      if (!scheduleState.present && newDateRange) {\n        return [newDateRange];\n      }\n\n      const newSchedule = [...scheduleState.present];\n\n      if (!newDateRange) {\n        newSchedule.splice(rangeIndex, 1);\n      } else {\n        newSchedule[rangeIndex] = newDateRange;\n      }\n\n      setSchedule(mergeRanges(newSchedule));\n    },\n    [scheduleState.present]\n  );\n\n  const getDateRangeForVisualGrid = useMemo(\n    () =>\n      createMapCellInfoToRecurringTimeRange({\n        originDate,\n        fromX: toDay,\n        fromY: y => y * visualGridVerticalPrecision\n      }),\n    [toDay, originDate, visualGridVerticalPrecision]\n  );\n\n  useEffect(() => {\n    if (!root.current || !root.current.contains(document.activeElement)) {\n      return;\n    }\n\n    document.activeElement &&\n      scrollIntoView(document.activeElement, {\n        scrollMode: 'if-needed',\n        block: 'nearest',\n        inline: 'nearest'\n      });\n  }, [root.current, document.activeElement, scheduleState.present]);\n\n  return (\n    <div ref={root} className={classes['root']}>\n      <div className={classes['timeline']}>\n        <div className={classes['header']}>\n          <div className={classes['day-column']}>\n            <div className={cc([classes['cell'], classes.title])}>Timeline</div>\n          </div>\n        </div>\n        <div className={classes['calendar']}>\n          <div className={classes['day-column']}>\n            <div className={classes['day-hours']}>\n              {times(48).map(timeIndex => {\n                let startText = '';\n                if (timeIndex % 2 === 0) {\n                  const [[start]] = getDateRangeForVisualGrid({\n                    startX: 0,\n                    startY: timeIndex,\n                    endX: 0,\n                    endY: timeIndex + 1,\n                    spanX: 1,\n                    spanY: 1\n                  });\n                  startText = format(start, 'h a');\n                }\n\n                return (\n                  <div key={timeIndex} className={classes['cell']}>\n                    <div className={classes['time']}>{startText}</div>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div>\n        <div className={cc([classes['calendar'], classes.header])}>\n          {times(7).map(i => (\n            <div key={i} className={classes['day-column']}>\n              <div className={cc([classes['cell'], classes.title])}>\n                {format(addDays(originDate, i), 'ddd')}\n              </div>\n            </div>\n          ))}\n        </div>\n        <div className={classes['layer-container']}>\n          {isDragging && (\n            <div className={classes['drag-box']} style={style}>\n              {hasFinishedDragging && <div className={classes['popup']} />}\n            </div>\n          )}\n          {grid && pendingCreation && isDragging && (\n            <Schedule\n              dateRangeToCells={dateRangeToCells}\n              cellInfoToDateRange={cellInfoToSingleDateRange}\n              className={classes['is-pending-creation']}\n              ranges={mergeEvents(scheduleState.present, pendingCreation)}\n              grid={grid}\n            />\n          )}\n          {grid && !pendingCreation && (\n            <Schedule\n              dateRangeToCells={dateRangeToCells}\n              cellInfoToDateRange={cellInfoToSingleDateRange}\n              isResizable\n              isMovable\n              isDeletable\n              onChange={handleEventChange}\n              ranges={scheduleState.present}\n              grid={grid}\n            />\n          )}\n\n          <div ref={parent} className={classes['calendar']}>\n            {times(7).map(dayIndex => {\n              return (\n                <div key={dayIndex} className={classes['day-column']}>\n                  <div className={classes['day-hours']}>\n                    {times(48).map(timeIndex => {\n                      return (\n                        <div key={timeIndex} className={classes['cell']}>\n                          <div className={classes['debug']}>\n                            ({dayIndex}, {timeIndex})\n                          </div>\n                        </div>\n                      );\n                    })}\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nconst rootElement = document.getElementById('root');\nReactDOM.render(<App verticalPrecision={1 / 30} />, rootElement);\n","import React, { useState, useEffect, useCallback } from 'react';\nimport { isEqual } from 'lodash';\nimport { fromEvent, merge } from 'rxjs';\nimport {\n  tap,\n  map,\n  takeUntil,\n  mergeMap,\n  startWith,\n  distinctUntilChanged,\n  filter\n} from 'rxjs/operators';\nimport { createPageMapCoordsToContainer } from '../utils/createPageMapCoordsToContainer';\nimport { Rect } from '../types';\n\nexport function useClickAndDrag(ref: React.RefObject<HTMLElement>) {\n  const [style, setStyle] = useState({ top: 0, left: 0, width: 0, height: 0 });\n  const [box, setBox] = useState<Rect | null>(null);\n  const [isDragging, setIsDragging] = useState(false);\n  const [hasFinishedDragging, setHasFinishedDragging] = useState(false);\n\n  useEffect(() => {\n    const container = ref.current;\n    if (!container) {\n      return;\n    }\n\n    const mapCoordsToContainer = createPageMapCoordsToContainer(container);\n\n    const touchStart$ = fromEvent<TouchEvent>(container, 'touchstart', {\n      passive: true\n    });\n    const touchMove$ = fromEvent<TouchEvent>(window, 'touchmove', {\n      passive: true\n    });\n    const touchEnd$ = fromEvent<TouchEvent>(window, 'touchend', {\n      passive: true\n    });\n\n    const mouseDown$ = fromEvent<MouseEvent>(container, 'mousedown', {\n      passive: true\n    }).pipe(filter(event => event.which === 1));\n    const mouseMove$ = fromEvent<MouseEvent>(window, 'mousemove', {\n      passive: true\n    });\n    const mouseUp$ = fromEvent<MouseEvent>(window, 'mouseup', {\n      passive: true\n    });\n\n    const dragStart$ = merge(mouseDown$, touchStart$).pipe(\n      tap(e => {\n        e.stopPropagation();\n        e.preventDefault();\n      }),\n      map(mapCoordsToContainer)\n    );\n\n    const dragEnd$ = merge(mouseUp$, touchEnd$).pipe(\n      map(mapCoordsToContainer),\n      tap(() => {\n        setIsDragging(false);\n        setHasFinishedDragging(true);\n      })\n    );\n    const move$ = merge(mouseMove$, touchMove$).pipe(map(mapCoordsToContainer));\n\n    const box$ = dragStart$.pipe(\n      tap(() => {\n        setIsDragging(true);\n        setHasFinishedDragging(false);\n      }),\n      mergeMap(down => {\n        return move$.pipe(\n          startWith(down),\n          map(\n            (move): Rect => {\n              const startX = Math.max(down.x, 0);\n              const startY = Math.max(down.y, 0);\n              const endX = Math.min(move.x, container.scrollWidth);\n              const endY = Math.min(move.y, container.scrollHeight);\n              const top = Math.min(startY, endY);\n              const bottom = Math.max(startY, endY);\n              const left = Math.min(startX, endX);\n              const right = Math.max(startX, endX);\n\n              return {\n                startX,\n                startY,\n                endX,\n                endY,\n                top,\n                bottom,\n                left,\n                right,\n                width: right - left,\n                height: bottom - top\n              };\n            }\n          ),\n          takeUntil(dragEnd$)\n        );\n      }),\n      distinctUntilChanged(isEqual)\n    );\n\n    const style$ = box$.pipe(\n      map(({ top, left, width, height }) => ({\n        top,\n        left,\n        width,\n        height\n      }))\n    );\n\n    const boxSubscriber = box$.subscribe(setBox);\n    const styleSubscriber = style$.subscribe(setStyle);\n\n    return () => {\n      boxSubscriber.unsubscribe();\n      styleSubscriber.unsubscribe();\n    };\n  }, []);\n\n  const cancel = useCallback(() => {\n    setIsDragging(false);\n    setHasFinishedDragging(false);\n    setBox(null);\n  }, [setBox]);\n\n  return { style, box, isDragging, cancel, hasFinishedDragging };\n}\n"],"sourceRoot":""}