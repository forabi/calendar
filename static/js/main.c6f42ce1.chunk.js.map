{"version":3,"sources":["hooks/useMousetrap.ts","components/RangeBox.tsx","components/Schedule.tsx","utils/createPageMapCoordsToContainer.ts","hooks/useScrollPosition.ts","hooks/useEventListener.ts","hooks/useStickyStyle.ts","utils/getSpan.ts","utils/createGridFromContainer.ts","utils/cellToDate.ts","utils/createMapCellInfoToContiguousDateRange.ts","utils/createMapCellInfoToRecurringTimeRange.ts","utils/createMapDateRangeToCells.ts","utils/mergeEvents.ts","index.tsx","hooks/useClickAndDrag.ts","styles.module.scss"],"names":["weakMap","WeakMap","useMousetrap","handlerKey","handlerCallback","element","actionRef","useRef","current","useEffect","instance","get","Mousetrap","set","bind","mousetrap","unbind","RangeBox","_ref","_ref3","classes","grid","isBeingEdited","rangeIndex","cellIndex","cellArray","cell","className","onChange","cellInfoToDateRange","isResizable","isDeletable","isMovable","ref","_useState","useState","_useState2","Object","slicedToArray","modifiedCell","setModifiedCell","originalRect","useMemo","getRectFromCell","rect","modifiedDateRange","useCallback","undefined","top","left","width","height","style","isStart","isEnd","length","handleStop","startY","newCell","objectSpread","endY","numVerticalCells","handleDrag","event","_ref2","y","preventDefault","stopPropagation","_start","_end","newTop","Math","min","newBottom","newRect","bottom","_grid$getCellFromRect","getCellFromRect","invariant","spanY","concat","handleResize","direction","delta","newSize","includes","_grid$getCellFromRect2","react_default","a","createElement","react_draggable_default","axis","bounds","totalHeight","right","totalWidth","position","x","onDrag","onStop","cancel","handle","classcat","defineProperty","tabIndex","lib","size","onResize","onResizeStop","handleWrapperClass","enable","handleClasses","bottomLeft","bottomRight","topLeft","topRight","format","Schedule","ranges","dateRangeToCells","map","dateRange","key","array","createPageMapCoordsToContainer","container","clientX","clientY","pageX","pageY","_event$changedTouches","changedTouches","_container$getBoundin","getBoundingClientRect","useScrollPosition","root","arguments","_ref$passive","passive","_ref$enabled","enabled","scrollTop","scrollLeft","setPosition","listener","options","addEventListener","removeEventListener","useEventListener","target","_event$target","useStickyStyle","scrollParent","_ref$top","_ref$left","_useScrollPosition","transform","zIndex","getSpan","x1","x2","abs","createGridForContainer","numHorizontalCells","cellWidth","cellHeight","data","endX","startX","spanX","this","clamp","floor","round","cellToDate","toMin","originDate","addMinutes","addDays","createMapCellInfoToContiguousDateRange","fromY","toDay","fromX","startDate","endDate","isBefore","createMapCellInfoToRecurringTimeRange","range","i","isEqual","startOfDay","endOfDay","subDays","sort","rangeA","rangeB","createMapDateRangeToCells","_ref$toX","toX","toY","start","end","originOfThisDay","_startX","differenceInDays","_startY","differenceInMinutes","_endX","_endY","cells","pop","mergeRanges","_mergeRanges","toConsumableArray","d","c","Date","mergeEvents","event1","event2","range1","range2","compareAsc","defaultSchedule","MINS_IN_DAY","horizontalPrecision","days","rootElement","document","getElementById","ReactDOM","render","_ref$verticalPrecisio","verticalPrecision","_ref$visualGridPrecis","visualGridPrecision","startOfWeek","weekStartsOn","mins","cellInfoToDateRanges","cellInfoToSingleDateRange","_cellInfoToDateRanges","_cellInfoToDateRanges2","toArray","first","rest","slice","parent","timelineStickyStyle","headerStickyStyle","useComponentSize","_useClickAndDrag","setStyle","_useState3","_useState4","box","setBox","_useState5","_useState6","isDragging","setIsDragging","_useState7","_useState8","hasFinishedDragging","setHasFinishedDragging","mapCoordsToContainer","touchMove$","fromEvent","window","touchEnd$","touchStartWithDelay$","pipe","mergeMap","of","delay","takeUntil","mouseDown$","filter","which","mouseMove$","mouseUp$","dragStart$","merge","tap","e","dragEnd$","move$","box$","down","startWith","move","max","scrollWidth","scrollHeight","distinctUntilChanged","style$","boxSubscriber","subscribe","styleSubscriber","unsubscribe","useClickAndDrag","pendingCreation","setPendingCreation","_useUndo","useUndo","dateString","_useUndo2","scheduleState","_useUndo2$","setSchedule","undoSchedule","undo","redoSchedule","redo","canUndoSchedule","canUndo","canRedoSchedule","canRedo","_useMemo","_parent$current","constrainedBox","dateRanges","present","handleEventChange","newDateRange","newSchedule","splice","getDateRangeForVisualGrid","contains","activeElement","scrollIntoView","scrollMode","block","inline","title","times","timeIndex","startText","_getDateRangeForVisua","_getDateRangeForVisua2","header","dayIndex","module","exports","no-scroll","timeline","debug","debug-active","calendar","react-draggable","handle-wrapper","layer-container","drag-box","draggable","button-reset","is-draggable","react-draggable-dragging","is-pending-creation","hours-container","day-column","day-hours","time","popup","range-boxes","event-content"],"mappings":"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","file":"static/js/main.c6f42ce1.chunk.js","sourcesContent":["import mousetrap from 'mousetrap';\nimport { useEffect, useRef } from 'react';\n\nconst weakMap = new WeakMap<typeof document | Element, MousetrapInstance>();\n\n/**\n * Use mousetrap hook\n *\n * @param handlerKey - A key, key combo or array of combos according to Mousetrap documentation.\n * @param  handlerCallback - A function that is triggered on key combo catch.\n */\nexport default function useMousetrap(\n  handlerKey: string | string[],\n  handlerCallback: () => void,\n  element: typeof document | Element | null\n) {\n  const actionRef = useRef<typeof handlerCallback | null>(null);\n  actionRef.current = handlerCallback;\n\n  useEffect(() => {\n    if (!element) {\n      return;\n    }\n\n    let instance = weakMap.get(element);\n\n    if (!instance) {\n      instance = new Mousetrap(element as Element);\n      weakMap.set(element, instance);\n    }\n\n    instance.bind(handlerKey, () => {\n      typeof actionRef.current === 'function' && actionRef.current();\n    });\n\n    return () => {\n      mousetrap.unbind(handlerKey);\n    };\n  }, [handlerKey, element]);\n}\n","import classcat from 'classcat';\nimport { format } from 'date-fns';\nimport invariant from 'invariant';\nimport Resizable, { ResizeCallback } from 're-resizable';\nimport React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState\n} from 'react';\nimport Draggable, { DraggableEventHandler } from 'react-draggable';\nimport useMousetrap from '../hooks/useMousetrap';\nimport { CellInfo, DateRange, Grid, OnChangeCallback } from '../types';\n\nexport function RangeBox({\n  classes,\n  grid,\n  isBeingEdited,\n  rangeIndex,\n  cellIndex,\n  cellArray,\n  cell,\n  className,\n  onChange,\n  cellInfoToDateRange,\n  isResizable,\n  isDeletable,\n  isMovable\n}: {\n  classes: Record<string, string>;\n  grid: Grid;\n  cell: CellInfo;\n  cellIndex: number;\n  cellArray: CellInfo[];\n  className?: string;\n  onChange?: OnChangeCallback;\n  isResizable?: boolean;\n  isDeletable?: boolean;\n  isMovable?: boolean;\n  rangeIndex: number;\n  isBeingEdited?(cell: CellInfo): boolean;\n  cellInfoToDateRange(cell: CellInfo): DateRange;\n}) {\n  const ref = useRef(null);\n  const [modifiedCell, setModifiedCell] = useState(cell);\n  const originalRect = useMemo(() => grid.getRectFromCell(cell), [cell, grid]);\n  const rect = useMemo(() => grid.getRectFromCell(modifiedCell), [\n    modifiedCell,\n    grid\n  ]);\n\n  useEffect(() => {\n    setModifiedCell(cell);\n  }, [cell]);\n\n  const modifiedDateRange = useMemo(() => cellInfoToDateRange(modifiedCell), [\n    modifiedCell\n  ]);\n\n  const handleDelete = useCallback(() => {\n    if (!isDeletable) {\n      return;\n    }\n\n    onChange && onChange(undefined, rangeIndex);\n  }, [ref.current, onChange, isDeletable, rangeIndex]);\n\n  useMousetrap('del', handleDelete, ref.current);\n\n  const { top, left, width, height } = rect;\n\n  const style = { width, height };\n\n  const isStart = cellIndex === 0;\n  const isEnd = cellIndex === cellArray.length - 1;\n\n  const handleStop = useCallback(() => {\n    onChange && onChange(cellInfoToDateRange(modifiedCell), rangeIndex);\n  }, [modifiedCell, rangeIndex, cellInfoToDateRange, onChange]);\n\n  useMousetrap(\n    'up',\n    () => {\n      if (!isMovable) {\n        return;\n      }\n\n      if (modifiedCell.startY === 0) {\n        return;\n      }\n\n      const newCell = {\n        ...modifiedCell,\n        startY: modifiedCell.startY - 1,\n        endY: modifiedCell.endY - 1\n      };\n\n      onChange && onChange(cellInfoToDateRange(newCell), rangeIndex);\n    },\n    ref.current\n  );\n\n  useMousetrap(\n    'down',\n    () => {\n      if (!isMovable) {\n        return;\n      }\n\n      if (modifiedCell.endY === grid.numVerticalCells - 1) {\n        return;\n      }\n\n      const newCell = {\n        ...modifiedCell,\n        startY: modifiedCell.startY + 1,\n        endY: modifiedCell.endY + 1\n      };\n\n      onChange && onChange(cellInfoToDateRange(newCell), rangeIndex);\n    },\n    ref.current\n  );\n\n  const handleDrag: DraggableEventHandler = useCallback(\n    (event, { y }) => {\n      if (!isMovable) {\n        return;\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n\n      const _start = y;\n      const _end = _start + rect.height;\n      const newTop = Math.min(_start, _end);\n      const newBottom = newTop + rect.height;\n\n      if (newTop === top) {\n        return;\n      }\n\n      const newRect = {\n        ...rect,\n        top: newTop,\n        bottom: newBottom\n      };\n\n      const { startY, endY } = grid.getCellFromRect(newRect);\n\n      const newCell = {\n        ...cell,\n        startY,\n        endY\n      };\n\n      invariant(\n        newCell.spanY === cell.spanY,\n        `Expected the dragged time cell to have the same height (${\n          newCell.spanY\n        }, ${cell.spanY})`\n      );\n      setModifiedCell(newCell);\n    },\n    [grid, rect, isMovable, setModifiedCell]\n  );\n\n  const handleResize: ResizeCallback = useCallback(\n    (event, direction, _ref, delta) => {\n      if (!isResizable) {\n        return;\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n\n      if (delta.height === 0) {\n        return;\n      }\n\n      const newSize = {\n        height: delta.height + rect.height,\n        width: delta.width + rect.width\n      };\n\n      const newRect = {\n        ...originalRect,\n        ...newSize\n      };\n\n      if (direction.includes('top')) {\n        newRect.top -= delta.height;\n      } else if (direction.includes('bottom')) {\n        newRect.bottom += delta.height;\n      }\n\n      const { spanY, startY, endY } = grid.getCellFromRect(newRect);\n      const newCell = {\n        ...cell,\n        spanY,\n        startY,\n        endY\n      };\n\n      setModifiedCell(newCell);\n    },\n    [grid, rect, isResizable, setModifiedCell, originalRect]\n  );\n\n  return (\n    <Draggable\n      axis={isMovable ? 'y' : 'none'}\n      bounds={{\n        top: 0,\n        bottom: grid.totalHeight - height,\n        left: 0,\n        right: grid.totalWidth\n      }}\n      position={{ x: left, y: top }}\n      onDrag={handleDrag}\n      onStop={handleStop}\n      cancel={`.${classes.handle}`}\n    >\n      <button\n        className={classcat([\n          classes['event'],\n          classes['button-reset'],\n          classes['range-box'],\n          className,\n          {\n            [classes['is-draggable']]: isMovable,\n            [classes['is-being-edited']]: isBeingEdited && isBeingEdited(cell)\n          }\n        ])}\n        ref={ref}\n        tabIndex={0}\n        style={style}\n      >\n        <Resizable\n          size={originalRect}\n          onResize={handleResize}\n          onResizeStop={handleStop}\n          handleWrapperClass={classes['handle-wrapper']}\n          enable={\n            isResizable\n              ? {\n                  top: true,\n                  bottom: true\n                }\n              : {}\n          }\n          handleClasses={{\n            bottom: classcat([classes['handle'], classes.bottom]),\n            bottomLeft: classcat([classes['handle'], classes['bottom-left']]),\n            bottomRight: classcat([classes['handle'], classes['bottom-right']]),\n            left: classcat([classes['handle'], classes.left]),\n            right: classcat([classes['handle'], classes.right]),\n            top: classcat([classes['handle'], classes.top]),\n            topLeft: classcat([classes['handle'], classes['top-left']]),\n            topRight: classcat([classes['handle'], classes['top-right']])\n          }}\n        >\n          <div className={classes['event-content']} style={style}>\n            <span className={classes['start']}>\n              {isStart && format(modifiedDateRange[0], 'h:mma')}\n            </span>\n            <span className={classes['end']}>\n              {isEnd && format(modifiedDateRange[1], 'h:mma')}\n            </span>\n          </div>\n        </Resizable>\n      </button>\n    </Draggable>\n  );\n}\n","import React from 'react';\nimport { CellInfo, DateRange, Event, Grid, OnChangeCallback } from '../types';\nimport { RangeBox } from './RangeBox';\n\nexport function Schedule({\n  classes,\n  ranges,\n  grid,\n  className,\n  onChange,\n  isResizable,\n  isDeletable,\n  isMovable,\n  cellInfoToDateRange,\n  dateRangeToCells,\n  isBeingEdited\n}: {\n  classes: Record<string, string>;\n  ranges: Event;\n  grid: Grid;\n  className?: string;\n  isResizable?: boolean;\n  isDeletable?: boolean;\n  isMovable?: boolean;\n  onChange?: OnChangeCallback;\n  dateRangeToCells(range: DateRange): CellInfo[];\n  isBeingEdited?(cell: CellInfo): boolean;\n  cellInfoToDateRange(cell: CellInfo): DateRange;\n}) {\n  return (\n    <div className={classes['range-boxes']}>\n      {ranges.map((dateRange, rangeIndex) => {\n        return (\n          <span key={rangeIndex}>\n            {dateRangeToCells(dateRange).map((cell, cellIndex, array) => {\n              return (\n                <RangeBox\n                  classes={classes}\n                  key={cellIndex}\n                  isResizable={isResizable}\n                  isMovable={isMovable}\n                  isDeletable={isDeletable}\n                  cellInfoToDateRange={cellInfoToDateRange}\n                  cellArray={array}\n                  cellIndex={cellIndex}\n                  rangeIndex={rangeIndex}\n                  className={className}\n                  isBeingEdited={isBeingEdited}\n                  onChange={onChange}\n                  grid={grid}\n                  cell={cell}\n                />\n              );\n            })}\n          </span>\n        );\n      })}\n    </div>\n  );\n}\n","export const createPageMapCoordsToContainer = (container: HTMLElement) => {\n  return (event: React.MouseEvent | MouseEvent | TouchEvent) => {\n    let clientX: number;\n    let clientY: number;\n    let pageX: number;\n    let pageY: number;\n\n    if ('changedTouches' in event) {\n      ({ clientX, clientY, pageX, pageY } = event.changedTouches[0]);\n    } else {\n      ({ clientX, clientY, pageX, pageY } = event);\n    }\n    const { top, left } = container.getBoundingClientRect();\n\n    return {\n      clientX,\n      clientY,\n      pageX,\n      pageY,\n      top,\n      left,\n      x: clientX - left,\n      y: clientY - top\n    };\n  };\n};\n","import { useState } from 'react';\nimport { useEventListener } from './useEventListener';\n\nexport function useScrollPosition(\n  root: React.RefObject<HTMLElement>,\n  { passive = true, enabled = true } = {}\n) {\n  const [position, setPosition] = useState({ scrollTop: 0, scrollLeft: 0 });\n\n  useEventListener(\n    root,\n    'scroll',\n    event => {\n      if (event && event.target) {\n        // @ts-ignore\n        const { scrollTop, scrollLeft } = event.target;\n        setPosition({ scrollTop, scrollLeft });\n      }\n    },\n    { passive },\n    { enabled }\n  );\n\n  return position;\n}\n","import { useEffect } from 'react';\n\nexport function useEventListener<\n  K extends keyof HTMLElementEventMap,\n  Element extends HTMLElement\n>(\n  ref: React.RefObject<Element>,\n  event: K,\n  listener: (this: Element, event: HTMLElementEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions,\n  { enabled = true } = {}\n) {\n  useEffect(() => {\n    if (ref.current === null) {\n      return;\n    }\n\n    if (enabled) {\n      ref.current.addEventListener(event, listener, options);\n    } else if (listener) {\n      ref.current.removeEventListener(event, listener);\n    }\n\n    return () => {\n      if (!ref.current) {\n        return;\n      }\n\n      ref.current.removeEventListener(event, listener);\n    };\n  }, [ref.current, listener, options, enabled]);\n}\n","import React, { useMemo } from 'react';\nimport { useScrollPosition } from './useScrollPosition';\n\nexport function useStickyStyle(\n  scrollParent: React.RefObject<HTMLElement>,\n  { top = false, left = false }: { top?: boolean; left?: boolean }\n) {\n  const { scrollLeft, scrollTop } = useScrollPosition(scrollParent, {\n    enabled: top || left\n  });\n\n  const stickyStyle = useMemo<React.CSSProperties>(\n    () => ({\n      transform: `translate(${left ? scrollLeft : 0}px, ${\n        top ? scrollTop : 0\n      }px)`,\n      zIndex: 3\n    }),\n    [left ? scrollLeft : 0, top ? scrollTop : 0]\n  );\n\n  return stickyStyle;\n}\n","export const getSpan = (x1: number, x2: number) => 1 + Math.abs(x2 - x1);\n","import { Grid, CellInfo, Rect } from '../types';\nimport { clamp, floor, round } from 'lodash';\nimport { getSpan } from './getSpan';\n\nexport const createGridForContainer = ({\n  totalHeight,\n  totalWidth,\n  numVerticalCells,\n  numHorizontalCells\n}: {\n  totalHeight: number;\n  totalWidth: number;\n  numVerticalCells: number;\n  numHorizontalCells: number;\n}): Grid => {\n  const cellHeight = totalHeight / numVerticalCells;\n  const cellWidth = totalWidth / numHorizontalCells;\n\n  return {\n    totalHeight,\n    totalWidth,\n    numVerticalCells,\n    numHorizontalCells,\n    cellWidth,\n    cellHeight,\n\n    getRectFromCell(data: CellInfo) {\n      const { endX, startX, endY, startY, spanX, spanY } = data;\n      const bottom = endY * this.cellHeight;\n      const top = startY * this.cellHeight;\n      const left = startX * this.cellWidth;\n      const right = endX * this.cellWidth;\n      const height = spanY * this.cellHeight;\n      const width = spanX * this.cellWidth;\n\n      return {\n        bottom,\n        top,\n        left,\n        right,\n        height,\n        width,\n\n        // @TODO: check the math\n        startX: startX * this.cellWidth,\n        endX: endX * this.cellWidth,\n        startY: startY * this.cellHeight,\n        endY: endY * this.cellHeight\n      };\n    },\n\n    getCellFromRect(data: Rect) {\n      const startX = clamp(\n        floor(data.left / this.cellWidth),\n        0,\n        numHorizontalCells - 1\n      );\n      const startY = clamp(\n        round(data.top / this.cellHeight),\n        0,\n        numVerticalCells - 1\n      );\n      const endX = clamp(\n        floor(data.right / this.cellWidth),\n        0,\n        numHorizontalCells - 1\n      );\n      const endY = clamp(\n        round(data.bottom / this.cellHeight),\n        0,\n        numVerticalCells - 1\n      );\n      const spanX = clamp(getSpan(startX, endX), 1, numHorizontalCells);\n      const spanY = clamp(getSpan(startY, endY), 1, numVerticalCells);\n\n      return {\n        spanX,\n        spanY,\n        startX,\n        startY,\n        endX,\n        endY\n      };\n    }\n  };\n};\n","import { addMinutes, addDays } from 'date-fns';\n\nexport const cellToDate = ({\n  startX,\n  startY,\n  toMin,\n  originDate\n}: {\n  startX: number;\n  startY: number;\n  toMin: (y: number) => number;\n  toDay: (x: number) => number;\n  originDate: Date;\n}) => addMinutes(addDays(originDate, startX), toMin(startY));\n","import { MapCellInfoToDateRange } from '../types';\nimport { isBefore } from 'date-fns';\nimport { cellToDate } from './cellToDate';\n\nexport const createMapCellInfoToContiguousDateRange: MapCellInfoToDateRange = ({\n  fromY: toMin,\n  fromX: toDay,\n  originDate\n}) => ({ startX, startY, endX, endY }) => {\n  const startDate = cellToDate({ startX, startY, toMin, toDay, originDate });\n  const endDate = cellToDate({\n    startX: endX,\n    startY: endY,\n    toMin,\n    toDay,\n    originDate\n  });\n\n  return [\n    isBefore(startDate, endDate) ? [startDate, endDate] : [endDate, startDate]\n  ];\n};\n","import { DateRange, MapCellInfoToDateRange } from '../types';\nimport { range } from 'lodash';\nimport {\n  addMinutes,\n  isBefore,\n  endOfDay,\n  isEqual,\n  subDays,\n  startOfDay\n} from 'date-fns';\nimport { cellToDate } from './cellToDate';\n\nexport type RecurringTimeRange = DateRange[];\n\nexport const createMapCellInfoToRecurringTimeRange: MapCellInfoToDateRange = ({\n  fromY: toMin,\n  fromX: toDay,\n  originDate\n}) => ({ startX, startY, endX, spanY }) => {\n  const result = range(startX, endX + 1)\n    .map(i => {\n      const startDate = cellToDate({\n        startX: i,\n        startY,\n        toMin,\n        toDay,\n        originDate\n      });\n      let endDate = addMinutes(startDate, toMin(spanY));\n\n      if (isEqual(endDate, startOfDay(endDate))) {\n        endDate = endOfDay(subDays(endDate, 1));\n      }\n\n      const range: DateRange = isBefore(startDate, endDate)\n        ? [startDate, endDate]\n        : [endDate, startDate];\n\n      return range;\n    })\n    .sort((rangeA, rangeB) => (isBefore(rangeA[0], rangeB[0]) ? 0 : 1));\n\n  return result;\n};\n","import { DateRange, CellInfo } from '../types';\nimport {\n  startOfDay,\n  differenceInDays,\n  differenceInMinutes,\n  isEqual\n} from 'date-fns';\nimport { range } from 'lodash';\nimport { getSpan } from './getSpan';\n\nexport const createMapDateRangeToCells = ({\n  toX = (x: number) => x,\n  toY,\n  numVerticalCells,\n  originDate\n}: {\n  toX: (day: number) => number;\n  toY: (min: number) => number;\n  numHorizontalCells: number;\n  numVerticalCells: number;\n  originDate: Date;\n}) => ([start, end]: DateRange): CellInfo[] => {\n  const originOfThisDay = startOfDay(start);\n  const _startX = toX(differenceInDays(start, originDate));\n  const _startY = toY(differenceInMinutes(start, originOfThisDay));\n  const _endX = toX(differenceInDays(end, originDate));\n  const _endY = toY(differenceInMinutes(end, startOfDay(end))) - 1;\n\n  const cells = range(_startX, _endX + 1).map(i => {\n    const startX = i;\n    const endX = i;\n    const atStart = i === _startX;\n    const atEnd = i === _endX;\n    const startY = !atStart ? 0 : _startY;\n    const endY = !atEnd ? numVerticalCells - 1 : _endY;\n    const spanX = getSpan(startX, endX);\n    const spanY = getSpan(startY, endY);\n\n    return {\n      startX,\n      startY,\n      endX,\n      endY,\n      spanX,\n      spanY\n    };\n  });\n\n  if (isEqual(end, startOfDay(end))) {\n    cells.pop();\n  }\n\n  return cells;\n};\n","import { Event } from '../types';\n// @ts-ignore\nimport _mergeRanges from 'merge-ranges';\nimport { compareAsc } from 'date-fns';\n\nexport function mergeRanges(event: Event): Event {\n  return _mergeRanges([...event].map(d => d.map(c => new Date(c))));\n}\n\nexport function mergeEvents(event1: Event, event2: Event | null): Event {\n  if (event2 === null) {\n    return event1;\n  }\n\n  return mergeRanges([...event1, ...event2]).sort((range1, range2) =>\n    compareAsc(range1[0], range2[0])\n  );\n}\n","import useComponentSize from '@rehooks/component-size';\nimport classcat from 'classcat';\nimport { addDays, compareAsc, format, startOfWeek } from 'date-fns';\nimport invariant from 'invariant';\nimport { times } from 'lodash';\nimport React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState\n} from 'react';\nimport ReactDOM from 'react-dom';\nimport 'resize-observer-polyfill/dist/ResizeObserver.global';\nimport scrollIntoView from 'scroll-into-view-if-needed';\nimport useUndo from 'use-undo';\nimport { Schedule } from './components/Schedule';\nimport { useClickAndDrag } from './hooks/useClickAndDrag';\nimport useMousetrap from './hooks/useMousetrap';\nimport { useStickyStyle } from './hooks/useStickyStyle';\nimport classes from './styles.module.scss';\nimport {\n  CellInfo,\n  DateRange,\n  Event as CalendarEvent,\n  Grid,\n  OnChangeCallback\n} from './types';\nimport { createGridForContainer } from './utils/createGridFromContainer';\nimport { createMapCellInfoToContiguousDateRange } from './utils/createMapCellInfoToContiguousDateRange';\nimport {\n  createMapCellInfoToRecurringTimeRange,\n  RecurringTimeRange\n} from './utils/createMapCellInfoToRecurringTimeRange';\nimport { createMapDateRangeToCells } from './utils/createMapDateRangeToCells';\nimport { mergeEvents, mergeRanges } from './utils/mergeEvents';\n\nconst defaultSchedule: [string, string][] = [\n  ['2019-03-03T22:45:00.000Z', '2019-03-04T01:15:00.000Z'],\n  ['2019-03-05T22:00:00.000Z', '2019-03-06T01:00:00.000Z'],\n  ['2019-03-04T22:15:00.000Z', '2019-03-05T01:00:00.000Z'],\n  ['2019-03-07T05:30:00.000Z', '2019-03-07T10:00:00.000Z'],\n  ['2019-03-08T22:00:00.000Z', '2019-03-09T01:00:00.000Z'],\n  ['2019-03-09T22:00:00.000Z', '2019-03-10T01:00:00.000Z'],\n  ['2019-03-06T22:00:00.000Z', '2019-03-07T01:00:00.000Z']\n];\n\nconst MINS_IN_DAY = 24 * 60;\nconst horizontalPrecision = 1;\nconst toDay = (x: number) => x / horizontalPrecision;\nconst toX = (days: number) => days * horizontalPrecision;\n\nfunction App({ verticalPrecision = 1 / 30, visualGridPrecision = 1 / 30 }) {\n  const originDate = startOfWeek(new Date('2019-03-04'), { weekStartsOn: 1 });\n\n  const numVerticalCells = MINS_IN_DAY * verticalPrecision;\n  const numHorizontalCells = 7 * horizontalPrecision;\n  const toMin = useCallback((y: number) => y / verticalPrecision, [\n    verticalPrecision\n  ]);\n  const toY = (mins: number) => mins * verticalPrecision;\n\n  const cellInfoToDateRanges = useMemo(\n    () =>\n      createMapCellInfoToRecurringTimeRange({\n        originDate,\n        fromY: toMin,\n        fromX: toDay\n      }),\n    [toMin, toDay, originDate]\n  );\n\n  const cellInfoToSingleDateRange = useCallback(\n    (cell: CellInfo): DateRange => {\n      const [first, ...rest] = cellInfoToDateRanges(cell);\n\n      invariant(\n        rest.length === 0,\n        `Expected \"cellInfoToSingleDateRange\" to return a single date range, found ${\n          rest.length\n        } additional ranges instead. This is a bug in @remotelock/weekly-scheduler`\n      );\n\n      return first;\n    },\n    [cellInfoToDateRanges]\n  );\n\n  const dateRangeToCells = useMemo(\n    () =>\n      createMapDateRangeToCells({\n        originDate,\n        numVerticalCells,\n        numHorizontalCells,\n        toX,\n        toY\n      }),\n    [toY, toX, numVerticalCells, numHorizontalCells, originDate]\n  );\n\n  const root = useRef<HTMLDivElement | null>(null);\n  const parent = useRef<HTMLDivElement | null>(null);\n  const timelineStickyStyle = useStickyStyle(root, { top: false, left: true });\n  const headerStickyStyle = useStickyStyle(root, { top: false, left: false });\n\n  const size = useComponentSize(parent);\n  const {\n    style,\n    box,\n    isDragging,\n    hasFinishedDragging,\n    cancel\n  } = useClickAndDrag(parent);\n  const [\n    pendingCreation,\n    setPendingCreation\n  ] = useState<RecurringTimeRange | null>(null);\n  const [\n    scheduleState,\n    {\n      set: setSchedule,\n      undo: undoSchedule,\n      redo: redoSchedule,\n      canUndo: canUndoSchedule,\n      canRedo: canRedoSchedule\n    }\n  ] = useUndo<CalendarEvent>(\n    defaultSchedule\n      .map(\n        range => range.map(dateString => new Date(dateString)) as [Date, Date]\n      )\n      .sort((range1, range2) => compareAsc(range1[0], range2[0]))\n  );\n\n  const { totalHeight, totalWidth } = useMemo(() => {\n    let totalHeight: number | null = null;\n    let totalWidth: number | null = null;\n    if (parent.current !== null) {\n      ({ scrollHeight: totalHeight, scrollWidth: totalWidth } = parent.current);\n    }\n\n    return { totalHeight, totalWidth };\n  }, [parent.current, size]);\n\n  const grid = useMemo<Grid | null>(() => {\n    if (totalHeight === null || totalWidth === null) {\n      return null;\n    }\n\n    return createGridForContainer({\n      totalHeight,\n      totalWidth,\n      numHorizontalCells,\n      numVerticalCells\n    });\n  }, [totalHeight, totalWidth, numHorizontalCells, numVerticalCells]);\n\n  useEffect(() => {\n    if (grid === null || box === null) {\n      setPendingCreation(null);\n      return;\n    }\n\n    const constrainedBox = box;\n    const cell = grid.getCellFromRect(constrainedBox);\n    const dateRanges = cellInfoToDateRanges(cell);\n    const event = dateRanges;\n    setPendingCreation(event);\n  }, [box, grid, setPendingCreation]);\n\n  useEffect(() => {\n    if (hasFinishedDragging) {\n      setSchedule(mergeEvents(scheduleState.present, pendingCreation));\n      setPendingCreation(null);\n    }\n  }, [\n    hasFinishedDragging,\n    setSchedule,\n    setPendingCreation,\n    pendingCreation,\n    scheduleState.present\n  ]);\n\n  useMousetrap(\n    'ctrl+z',\n    () => {\n      if (!canUndoSchedule) {\n        return;\n      }\n\n      undoSchedule();\n    },\n    document\n  );\n\n  useMousetrap(\n    'ctrl+shift+z',\n    () => {\n      if (!canRedoSchedule) {\n        return;\n      }\n\n      redoSchedule();\n    },\n    document\n  );\n\n  useMousetrap(\n    'esc',\n    () => {\n      if (pendingCreation) {\n        cancel();\n      }\n    },\n    document\n  );\n\n  useEffect(() => {\n    cancel();\n  }, [size]);\n\n  const handleEventChange = useCallback<OnChangeCallback>(\n    (newDateRange, rangeIndex) => {\n      if (!scheduleState.present && newDateRange) {\n        return [newDateRange];\n      }\n\n      const newSchedule = [...scheduleState.present];\n\n      if (!newDateRange) {\n        newSchedule.splice(rangeIndex, 1);\n      } else {\n        newSchedule[rangeIndex] = newDateRange;\n      }\n\n      setSchedule(mergeRanges(newSchedule));\n    },\n    [scheduleState.present]\n  );\n\n  const getDateRangeForVisualGrid = useMemo(\n    () =>\n      createMapCellInfoToContiguousDateRange({\n        originDate,\n        fromX: toDay,\n        fromY: y => y / visualGridPrecision\n      }),\n    [visualGridPrecision, toDay, originDate]\n  );\n\n  useEffect(() => {\n    if (!root.current || !root.current.contains(document.activeElement)) {\n      return;\n    }\n\n    document.activeElement &&\n      scrollIntoView(document.activeElement, {\n        scrollMode: 'if-needed',\n        block: 'nearest',\n        inline: 'nearest'\n      });\n  }, [root.current, document.activeElement, scheduleState.present]);\n\n  return (\n    <div\n      ref={root}\n      className={classcat([\n        classes['root'],\n        { [classes['no-scroll']]: isDragging }\n      ])}\n    >\n      <div style={timelineStickyStyle} className={classes['timeline']}>\n        <div className={classes['header']}>\n          <div className={classes['day-column']}>\n            <div className={classcat([classes['cell'], classes.title])}>T</div>\n          </div>\n        </div>\n        <div className={classes['calendar']}>\n          <div className={classes['day-column']}>\n            <div className={classes['day-hours']}>\n              {times(48).map(timeIndex => {\n                let startText = '';\n                if (timeIndex % 2 === 0) {\n                  const [[start]] = getDateRangeForVisualGrid({\n                    startX: 0,\n                    startY: timeIndex,\n                    endX: 0,\n                    endY: timeIndex + 1,\n                    spanX: 1,\n                    spanY: 1\n                  });\n                  startText = format(start, 'h a');\n                }\n\n                return (\n                  <div key={timeIndex} className={classes['cell']}>\n                    <div className={classes['time']}>{startText}</div>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div>\n        <div\n          style={headerStickyStyle}\n          className={classcat([classes['calendar'], classes.header])}\n        >\n          {times(7).map(i => (\n            <div key={i} className={classes['day-column']}>\n              <div className={classcat([classes['cell'], classes.title])}>\n                {format(addDays(originDate, i), 'ddd')}\n              </div>\n            </div>\n          ))}\n        </div>\n        <div className={classes['layer-container']}>\n          {isDragging && (\n            <div className={classes['drag-box']} style={style}>\n              {hasFinishedDragging && <div className={classes['popup']} />}\n            </div>\n          )}\n          {grid && pendingCreation && isDragging && (\n            <Schedule\n              classes={classes}\n              dateRangeToCells={dateRangeToCells}\n              cellInfoToDateRange={cellInfoToSingleDateRange}\n              className={classes['is-pending-creation']}\n              ranges={mergeEvents(scheduleState.present, pendingCreation)}\n              grid={grid}\n            />\n          )}\n          {grid && !pendingCreation && (\n            <Schedule\n              classes={classes}\n              dateRangeToCells={dateRangeToCells}\n              cellInfoToDateRange={cellInfoToSingleDateRange}\n              isResizable\n              isMovable\n              isDeletable\n              onChange={handleEventChange}\n              ranges={scheduleState.present}\n              grid={grid}\n            />\n          )}\n\n          <div ref={parent} className={classes['calendar']}>\n            {times(7).map(dayIndex => {\n              return (\n                <div key={dayIndex} className={classes['day-column']}>\n                  <div className={classes['day-hours']}>\n                    {times(48).map(timeIndex => {\n                      return (\n                        <div key={timeIndex} className={classes['cell']}>\n                          <div className={classes['debug']}>\n                            ({dayIndex}, {timeIndex})\n                          </div>\n                        </div>\n                      );\n                    })}\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nconst rootElement = document.getElementById('root');\nReactDOM.render(<App verticalPrecision={1 / 30} />, rootElement);\n","import React, { useState, useEffect, useCallback } from 'react';\nimport { isEqual } from 'lodash';\nimport { fromEvent, merge, of } from 'rxjs';\nimport {\n  tap,\n  map,\n  takeUntil,\n  mergeMap,\n  startWith,\n  distinctUntilChanged,\n  filter,\n  delay\n} from 'rxjs/operators';\nimport { createPageMapCoordsToContainer } from '../utils/createPageMapCoordsToContainer';\nimport { Rect } from '../types';\n\nexport function useClickAndDrag(ref: React.RefObject<HTMLElement>) {\n  const [style, setStyle] = useState({ top: 0, left: 0, width: 0, height: 0 });\n  const [box, setBox] = useState<Rect | null>(null);\n  const [isDragging, setIsDragging] = useState(false);\n  const [hasFinishedDragging, setHasFinishedDragging] = useState(false);\n\n  useEffect(() => {\n    const container = ref.current;\n    if (!container) {\n      return;\n    }\n\n    const mapCoordsToContainer = createPageMapCoordsToContainer(container);\n\n    const touchMove$ = fromEvent<TouchEvent>(window, 'touchmove', {\n      passive: false\n    });\n    const touchEnd$ = fromEvent<TouchEvent>(window, 'touchend', {\n      passive: true\n    });\n\n    const touchStart$ = fromEvent<TouchEvent>(container, 'touchstart', {\n      passive: false\n    });\n\n    const touchStartWithDelay$ = touchStart$.pipe(\n      mergeMap(start =>\n        of(start).pipe(\n          delay(300),\n          takeUntil(touchMove$)\n        )\n      )\n    );\n\n    const mouseDown$ = fromEvent<MouseEvent>(container, 'mousedown', {\n      passive: true\n    }).pipe(filter(event => event.which === 1));\n\n    const mouseMove$ = fromEvent<MouseEvent>(window, 'mousemove', {\n      passive: true\n    });\n\n    const mouseUp$ = fromEvent<MouseEvent>(window, 'mouseup', {\n      passive: true\n    });\n\n    const dragStart$ = merge(mouseDown$, touchStartWithDelay$).pipe(\n      tap(e => {\n        e.preventDefault();\n        e.stopPropagation();\n      }),\n      map(mapCoordsToContainer)\n    );\n\n    const dragEnd$ = merge(mouseUp$, touchEnd$).pipe(\n      map(mapCoordsToContainer),\n      tap(() => {\n        setIsDragging(false);\n        setHasFinishedDragging(true);\n      })\n    );\n\n    const move$ = merge(mouseMove$, touchMove$).pipe(\n      tap(e => {\n        e.preventDefault();\n        e.stopPropagation();\n      }),\n      map(mapCoordsToContainer)\n    );\n\n    const box$ = dragStart$.pipe(\n      tap(() => {\n        setIsDragging(true);\n        setHasFinishedDragging(false);\n      }),\n      mergeMap(down => {\n        return move$.pipe(\n          startWith(down),\n          map(\n            (move): Rect => {\n              const startX = Math.max(down.x, 0);\n              const startY = Math.max(down.y, 0);\n              const endX = Math.min(move.x, container.scrollWidth);\n              const endY = Math.min(move.y, container.scrollHeight);\n              const top = Math.min(startY, endY);\n              const bottom = Math.max(startY, endY);\n              const left = Math.min(startX, endX);\n              const right = Math.max(startX, endX);\n\n              return {\n                startX,\n                startY,\n                endX,\n                endY,\n                top,\n                bottom,\n                left,\n                right,\n                width: right - left,\n                height: bottom - top\n              };\n            }\n          ),\n          takeUntil(dragEnd$)\n        );\n      }),\n      distinctUntilChanged(isEqual)\n    );\n\n    const style$ = box$.pipe(\n      map(({ top, left, width, height }) => ({\n        top,\n        left,\n        width,\n        height\n      }))\n    );\n\n    const boxSubscriber = box$.subscribe(setBox);\n    const styleSubscriber = style$.subscribe(setStyle);\n\n    return () => {\n      boxSubscriber.unsubscribe();\n      styleSubscriber.unsubscribe();\n    };\n  }, []);\n\n  const cancel = useCallback(() => {\n    setIsDragging(false);\n    setHasFinishedDragging(false);\n    setBox(null);\n  }, [setBox]);\n\n  return { style, box, isDragging, cancel, hasFinishedDragging };\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"no-scroll\":\"styles_no-scroll__1vsU8\",\"root\":\"styles_root__3QAxj\",\"timeline\":\"styles_timeline__106Mk\",\"debug\":\"styles_debug__2SKKM\",\"debug-active\":\"styles_debug-active___9OUc\",\"calendar\":\"styles_calendar__3Xx2Y\",\"react-draggable\":\"styles_react-draggable__2QRVw\",\"handle-wrapper\":\"styles_handle-wrapper__2T7f7\",\"handle\":\"styles_handle__1dKGL\",\"top\":\"styles_top__2FFal\",\"bottom\":\"styles_bottom__3nd0X\",\"layer-container\":\"styles_layer-container__1Quoi\",\"event\":\"styles_event__bjik1\",\"drag-box\":\"styles_drag-box__OvX9t\",\"draggable\":\"styles_draggable__a1ktL\",\"button-reset\":\"styles_button-reset__3_zQt\",\"is-draggable\":\"styles_is-draggable__2U2x2\",\"react-draggable-dragging\":\"styles_react-draggable-dragging__1T3s8\",\"is-pending-creation\":\"styles_is-pending-creation__2vDDI\",\"hours-container\":\"styles_hours-container__3XZzL\",\"day-column\":\"styles_day-column__2sQzS\",\"day-hours\":\"styles_day-hours__3_7p4\",\"cell\":\"styles_cell__1OJUD\",\"time\":\"styles_time__1X-Hn\",\"title\":\"styles_title__2dKTz\",\"header\":\"styles_header__1IF59\",\"first\":\"styles_first__1t63n\",\"popup\":\"styles_popup__2oSt1\",\"range-boxes\":\"styles_range-boxes__39XBE\",\"event-content\":\"styles_event-content__1EBie\",\"start\":\"styles_start__2DXVx\",\"end\":\"styles_end__2XnIt\"};"],"sourceRoot":""}