{"version":3,"sources":["styles.module.scss","utils/createPageMapCoordsToContainer.ts","hooks/useClickAndDrag.ts","hooks/useMousetrap.ts","hooks/useScrollPosition.ts","hooks/useEventListener.ts","hooks/useStickyStyle.ts","utils/getSpan.ts","utils/cellToDate.ts","utils/mergeEvents.ts","components/Cell.tsx","utils/getTextForDateRange.ts","components/RangeBox.tsx","components/Schedule.tsx","components/TimeGridScheduler.tsx","utils/createMapCellInfoToRecurringTimeRange.ts","utils/createMapDateRangeToCells.ts","utils/createGrid.ts","utils/createMapCellInfoToContiguousDateRange.ts","index.tsx"],"names":["module","exports","no-scroll","root","timeline","debug","debug-active","calendar","react-draggable","handle-wrapper","handle","top","bottom","layer-container","event","drag-box","draggable","button-reset","is-draggable","react-draggable-dragging","is-pending-creation","hours-container","day-column","day-hours","cell","time","title","is-hour-start","header","first","popup","range-boxes","event-content","start","end","createPageMapCoordsToContainer","container","clientX","clientY","pageX","pageY","_event$changedTouches","changedTouches","_container$getBoundin","getBoundingClientRect","left","x","y","prevent","tap","e","preventDefault","stopPropagation","weakMap","WeakMap","useMousetrap","handlerKey","handlerCallback","element","actionRef","useRef","current","useEffect","instance","get","Mousetrap","set","bind","mousetrap","unbind","useScrollPosition","_ref","arguments","length","undefined","_ref$passive","passive","_ref$enabled","enabled","_useState","useState","scrollTop","scrollLeft","_useState2","Object","slicedToArray","position","setPosition","ref","listener","options","addEventListener","removeEventListener","useEventListener","target","_event$target","useStickyStyle","scrollParent","_ref$top","_ref$left","_useScrollPosition","useMemo","transform","concat","zIndex","getSpan","x1","x2","Math","abs","cellToDate","startX","startY","toMin","originDate","addMinutes","addDays","mergeRanges","_mergeRanges","toConsumableArray","map","d","c","Date","mergeEvents","event1","event2","sort","range1","range2","compareAsc","Cell","React","memo","timeIndex","children","classes","_getDateRangeForVisua","getDateRangeForVisualGrid","endX","endY","spanX","spanY","_getDateRangeForVisua2","isHourStart","getMinutes","react_default","a","createElement","className","classcat","defineProperty","formatHour","date","format","getTextForDateRange","dates","template","template2","isSameDay","_dropSame","takeSecond","_dates$map","_dates$map2","second","dropSame","_dropSame2","firstM","secondM","startDateStr","endDateStr","RangeBox","_ref3","grid","isBeingEdited","rangeIndex","cellIndex","cellArray","onChange","cellInfoToDateRange","isResizable","isDeletable","moveAxis","onActiveChange","modifiedCell","setModifiedCell","originalRect","getRectFromCell","rect","modifiedDateRange","useCallback","width","height","isStart","isEnd","handleStop","newCell","objectSpread","numVerticalCells","handleDrag","_ref2","newRect","_startY","_endY","newTop","min","newBottom","_startX","_endX","newLeft","newRight","right","_grid$getCellFromRect","getCellFromRect","invariant","handleResize","direction","delta","newSize","includes","_grid$getCellFromRect2","handleOnFocus","handleOnBlur","react_draggable_default","axis","bounds","totalHeight","totalWidth","onDrag","onStop","cancel","onFocus","onBlur","tabIndex","style","lib","size","onResize","onResizeStop","handleWrapperClass","enable","handleClasses","bottomLeft","bottomRight","topLeft","topRight","visually_hidden_es","aria-hidden","Schedule","ranges","isMovable","dateRangeToCells","onActive","dateRange","key","array","RangeBox_RangeBox","toDay","toX","days","TimeGridScheduler","_ref$verticalPrecisio","verticalPrecision","_ref$visualGridVertic","visualGridVerticalPrecision","schedule","_ref$originDate","toY","mins","cellInfoToDateRanges","fromY","fromX","range","i","startDate","endDate","isEqual","startOfDay","endOfDay","subDays","isBefore","createMapCellInfoToRecurringTimeRange","cellInfoToSingleDateRange","_cellInfoToDateRanges","_cellInfoToDateRanges2","toArray","rest","slice","_ref$toX","originOfThisDay","differenceInDays","differenceInMinutes","cells","pop","createMapDateRangeToCells","numHorizontalCells","parent","timelineStickyStyle","headerStickyStyle","useComponentSize","_useClickAndDrag","setStyle","_useState3","_useState4","box","setBox","_useState5","_useState6","isDragging","setIsDragging","_useState7","_useState8","hasFinishedDragging","setHasFinishedDragging","mapCoordsToContainer","touchMove$","fromEvent","window","pipe","touchEnd$","touchStartWithDelay$","mergeMap","of","delay","takeUntil","mouseDown$","filter","which","mouseMove$","mouseUp$","dragStart$","merge","dragEnd$","move$","box$","down","startWith","move","max","scrollWidth","scrollHeight","distinctUntilChanged","style$","boxSubscriber","subscribe","styleSubscriber","unsubscribe","useClickAndDrag","pendingCreation","setPendingCreation","_useUndo","useUndo","_useUndo2","scheduleState","_useUndo2$","setSchedule","undoSchedule","undo","redoSchedule","redo","canUndoSchedule","canUndo","canRedoSchedule","canRedo","_useMemo","_parent$current","cellHeight","floor","cellWidth","data","this","clamp","round","createGrid","constrainedBox","dateRanges","present","document","handleEventChange","newDateRange","newSchedule","splice","createMapCellInfoToContiguousDateRange","activeElement","contains","scrollIntoView","scrollMode","block","inline","numVisualVerticalCells","Fragment","disabled","onClick","times","Cell_Cell","role","Schedule_Schedule","dayIndex","defaultSchedule","dateString","rootElement","getElementById","ReactDOM","render","TimeGridScheduler_TimeGridScheduler","startOfWeek","weekStartsOn"],"mappings":"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","file":"static/js/main.3983c602.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"no-scroll\":\"styles_no-scroll__1vsU8\",\"root\":\"styles_root__3QAxj\",\"timeline\":\"styles_timeline__106Mk\",\"debug\":\"styles_debug__2SKKM\",\"debug-active\":\"styles_debug-active___9OUc\",\"calendar\":\"styles_calendar__3Xx2Y\",\"react-draggable\":\"styles_react-draggable__2QRVw\",\"handle-wrapper\":\"styles_handle-wrapper__2T7f7\",\"handle\":\"styles_handle__1dKGL\",\"top\":\"styles_top__2FFal\",\"bottom\":\"styles_bottom__3nd0X\",\"layer-container\":\"styles_layer-container__1Quoi\",\"event\":\"styles_event__bjik1\",\"drag-box\":\"styles_drag-box__OvX9t\",\"draggable\":\"styles_draggable__a1ktL\",\"button-reset\":\"styles_button-reset__3_zQt\",\"is-draggable\":\"styles_is-draggable__2U2x2\",\"react-draggable-dragging\":\"styles_react-draggable-dragging__1T3s8\",\"is-pending-creation\":\"styles_is-pending-creation__2vDDI\",\"hours-container\":\"styles_hours-container__3XZzL\",\"day-column\":\"styles_day-column__2sQzS\",\"day-hours\":\"styles_day-hours__3_7p4\",\"cell\":\"styles_cell__1OJUD\",\"time\":\"styles_time__1X-Hn\",\"title\":\"styles_title__2dKTz\",\"is-hour-start\":\"styles_is-hour-start__1Doa3\",\"header\":\"styles_header__1IF59\",\"first\":\"styles_first__1t63n\",\"popup\":\"styles_popup__2oSt1\",\"range-boxes\":\"styles_range-boxes__39XBE\",\"event-content\":\"styles_event-content__1EBie\",\"start\":\"styles_start__2DXVx\",\"end\":\"styles_end__2XnIt\"};","export const createPageMapCoordsToContainer = (container: HTMLElement) => {\n  return (event: React.MouseEvent | MouseEvent | TouchEvent) => {\n    let clientX: number;\n    let clientY: number;\n    let pageX: number;\n    let pageY: number;\n\n    if ('changedTouches' in event) {\n      ({ clientX, clientY, pageX, pageY } = event.changedTouches[0]);\n    } else {\n      ({ clientX, clientY, pageX, pageY } = event);\n    }\n    const { top, left } = container.getBoundingClientRect();\n\n    return {\n      clientX,\n      clientY,\n      pageX,\n      pageY,\n      top,\n      left,\n      x: clientX - left,\n      y: clientY - top\n    };\n  };\n};\n","import React, { useState, useEffect, useCallback } from 'react';\nimport { isEqual } from 'lodash';\nimport { fromEvent, merge, of } from 'rxjs';\nimport {\n  tap,\n  map,\n  takeUntil,\n  mergeMap,\n  startWith,\n  distinctUntilChanged,\n  filter,\n  delay\n} from 'rxjs/operators';\nimport { createPageMapCoordsToContainer } from '../utils/createPageMapCoordsToContainer';\nimport { Rect } from '../types';\n\nconst prevent = tap((e: TouchEvent) => {\n  e.preventDefault();\n  e.stopPropagation();\n});\n\nexport function useClickAndDrag(ref: React.RefObject<HTMLElement>) {\n  const [style, setStyle] = useState({\n    transform: 'translate(0, 0)',\n    width: 0,\n    height: 0\n  });\n  const [box, setBox] = useState<Rect | null>(null);\n  const [isDragging, setIsDragging] = useState(false);\n  const [hasFinishedDragging, setHasFinishedDragging] = useState(false);\n\n  useEffect(() => {\n    const container = ref.current;\n    if (!container) {\n      return;\n    }\n\n    const mapCoordsToContainer = createPageMapCoordsToContainer(container);\n\n    const touchMove$ = fromEvent<TouchEvent>(window, 'touchmove', {\n      passive: false\n    }).pipe(prevent);\n\n    const touchEnd$ = fromEvent<TouchEvent>(window, 'touchend', {\n      passive: true\n    });\n\n    const touchStart$ = fromEvent<TouchEvent>(container, 'touchstart', {\n      passive: false\n    });\n\n    const touchStartWithDelay$ = touchStart$.pipe(\n      mergeMap(start =>\n        of(start).pipe(\n          delay(300),\n          takeUntil(touchMove$),\n          prevent\n        )\n      )\n    );\n\n    const mouseDown$ = fromEvent<MouseEvent>(container, 'mousedown', {\n      passive: true\n    }).pipe(filter(event => event.which === 1));\n\n    const mouseMove$ = fromEvent<MouseEvent>(window, 'mousemove', {\n      passive: true\n    });\n\n    const mouseUp$ = fromEvent<MouseEvent>(window, 'mouseup', {\n      passive: true\n    });\n\n    const dragStart$ = merge(mouseDown$, touchStartWithDelay$).pipe(\n      map(mapCoordsToContainer)\n    );\n\n    const dragEnd$ = merge(mouseUp$, touchEnd$).pipe(\n      map(mapCoordsToContainer),\n      tap(() => {\n        setIsDragging(false);\n        setHasFinishedDragging(true);\n      })\n    );\n\n    const move$ = merge(mouseMove$, touchMove$).pipe(map(mapCoordsToContainer));\n\n    const box$ = dragStart$.pipe(\n      tap(() => {\n        setIsDragging(true);\n        setHasFinishedDragging(false);\n      }),\n      mergeMap(down => {\n        return move$.pipe(\n          startWith(down),\n          map(\n            (move): Rect => {\n              const startX = Math.max(down.x, 0);\n              const startY = Math.max(down.y, 0);\n              const endX = Math.min(move.x, container.scrollWidth);\n              const endY = Math.min(move.y, container.scrollHeight);\n              const top = Math.min(startY, endY);\n              const bottom = Math.max(startY, endY);\n              const left = Math.min(startX, endX);\n              const right = Math.max(startX, endX);\n\n              return {\n                startX,\n                startY,\n                endX,\n                endY,\n                top,\n                bottom,\n                left,\n                right,\n                width: right - left,\n                height: bottom - top\n              };\n            }\n          ),\n          takeUntil(dragEnd$)\n        );\n      }),\n      distinctUntilChanged(isEqual)\n    );\n\n    const style$ = box$.pipe(\n      map(({ top, left, width, height }) => ({\n        transform: `translate(${left}px, ${top}px)`,\n        width,\n        height\n      }))\n    );\n\n    const boxSubscriber = box$.subscribe(setBox);\n    const styleSubscriber = style$.subscribe(setStyle);\n\n    return () => {\n      boxSubscriber.unsubscribe();\n      styleSubscriber.unsubscribe();\n    };\n  }, [ref.current]);\n\n  const cancel = useCallback(() => {\n    setIsDragging(false);\n    setHasFinishedDragging(false);\n    setBox(null);\n  }, [setBox]);\n\n  return { style, box, isDragging, cancel, hasFinishedDragging };\n}\n","import mousetrap from 'mousetrap';\nimport { useEffect, useRef } from 'react';\n\nconst weakMap = new WeakMap<typeof document | Element, MousetrapInstance>();\n\n/**\n * Use mousetrap hook\n *\n * @param handlerKey - A key, key combo or array of combos according to Mousetrap documentation.\n * @param  handlerCallback - A function that is triggered on key combo catch.\n */\nexport default function useMousetrap(\n  handlerKey: string | string[],\n  handlerCallback: () => void,\n  element: typeof document | Element | null\n) {\n  const actionRef = useRef<typeof handlerCallback | null>(null);\n  actionRef.current = handlerCallback;\n\n  useEffect(() => {\n    if (!element) {\n      return;\n    }\n\n    let instance = weakMap.get(element);\n\n    if (!instance) {\n      instance = new Mousetrap(element as Element);\n      weakMap.set(element, instance);\n    }\n\n    instance.bind(handlerKey, () => {\n      typeof actionRef.current === 'function' && actionRef.current();\n    });\n\n    return () => {\n      mousetrap.unbind(handlerKey);\n    };\n  }, [handlerKey, element]);\n}\n","import { useState } from 'react';\nimport { useEventListener } from './useEventListener';\n\nexport function useScrollPosition(\n  root: React.RefObject<HTMLElement>,\n  { passive = true, enabled = true } = {}\n) {\n  const [position, setPosition] = useState({ scrollTop: 0, scrollLeft: 0 });\n\n  useEventListener(\n    root,\n    'scroll',\n    event => {\n      if (event && event.target) {\n        // @ts-ignore\n        const { scrollTop, scrollLeft } = event.target;\n        setPosition({ scrollTop, scrollLeft });\n      }\n    },\n    { passive },\n    { enabled }\n  );\n\n  return position;\n}\n","import { useEffect } from 'react';\n\nexport function useEventListener<\n  K extends keyof HTMLElementEventMap,\n  Element extends HTMLElement\n>(\n  ref: React.RefObject<Element>,\n  event: K,\n  listener: (this: Element, event: HTMLElementEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions,\n  { enabled = true } = {}\n) {\n  useEffect(() => {\n    if (ref.current === null) {\n      return;\n    }\n\n    if (enabled) {\n      ref.current.addEventListener(event, listener, options);\n    } else if (listener) {\n      ref.current.removeEventListener(event, listener);\n    }\n\n    return () => {\n      if (!ref.current) {\n        return;\n      }\n\n      ref.current.removeEventListener(event, listener);\n    };\n  }, [ref.current, listener, options, enabled]);\n}\n","import React, { useMemo } from 'react';\nimport { useScrollPosition } from './useScrollPosition';\n\nexport function useStickyStyle(\n  scrollParent: React.RefObject<HTMLElement>,\n  { top = false, left = false }: { top?: boolean; left?: boolean }\n) {\n  const { scrollLeft, scrollTop } = useScrollPosition(scrollParent, {\n    enabled: top || left\n  });\n\n  const stickyStyle = useMemo<React.CSSProperties>(\n    () => ({\n      transform: `translate(${left ? scrollLeft : 0}px, ${\n        top ? scrollTop : 0\n      }px)`,\n      zIndex: 3\n    }),\n    [left ? scrollLeft : 0, top ? scrollTop : 0]\n  );\n\n  return stickyStyle;\n}\n","export const getSpan = (x1: number, x2: number) => 1 + Math.abs(x2 - x1);\n","import { addMinutes, addDays } from 'date-fns';\n\nexport const cellToDate = ({\n  startX,\n  startY,\n  toMin,\n  originDate\n}: {\n  startX: number;\n  startY: number;\n  toMin: (y: number) => number;\n  toDay: (x: number) => number;\n  originDate: Date;\n}) => addMinutes(addDays(originDate, startX), toMin(startY));\n","import { Event } from '../types';\n// @ts-ignore\nimport _mergeRanges from 'merge-ranges';\nimport { compareAsc } from 'date-fns';\n\nexport function mergeRanges(event: Event): Event {\n  return _mergeRanges([...event].map(d => d.map(c => new Date(c))));\n}\n\nexport function mergeEvents(event1: Event, event2: Event | null): Event {\n  if (event2 === null) {\n    return event1;\n  }\n\n  return mergeRanges([...event1, ...event2]).sort((range1, range2) =>\n    compareAsc(range1[0], range2[0])\n  );\n}\n","import classcat from 'classcat';\nimport { getMinutes } from 'date-fns';\nimport React from 'react';\nimport { CellInfo, DateRange } from '../types';\n\nexport const Cell = React.memo(function Cell({\n  timeIndex,\n  children,\n  classes,\n  getDateRangeForVisualGrid\n}: {\n  timeIndex: number;\n  classes: Record<string, string>;\n  getDateRangeForVisualGrid(cell: CellInfo): DateRange[];\n  children?(options: { start: Date; isHourStart: boolean }): React.ReactNode;\n}) {\n  const [[start]] = getDateRangeForVisualGrid({\n    startX: 0,\n    startY: timeIndex,\n    endX: 0,\n    endY: timeIndex + 1,\n    spanX: 1,\n    spanY: 1\n  });\n\n  const isHourStart = getMinutes(start) === 0;\n\n  return (\n    <div\n      className={classcat([\n        classes['cell'],\n        { [classes['is-hour-start']]: isHourStart }\n      ])}\n    >\n      {children && children({ start, isHourStart })}\n    </div>\n  );\n});\n","import { isSameDay, format, getMinutes } from 'date-fns';\n\nconst dropSame = (\n  dates: [Date, Date],\n  template: string,\n  takeSecond: boolean = false\n) => {\n  const [first, second] = dates.map(date => format(date, template));\n  if (first !== second) {\n    return [first, second];\n  }\n\n  if (takeSecond) {\n    return ['', second];\n  }\n\n  return [first, ''];\n};\n\nconst formatHour = (date: Date) => {\n  if (getMinutes(date) === 0) {\n    return format(date, 'h');\n  }\n\n  return format(date, 'h:m');\n};\n\nexport const getTextForDateRange = (\n  dates: [Date, Date],\n  template?: string,\n  template2?: string\n) => {\n  const start = dates[0];\n  const end = dates[dates.length - 1];\n\n  if (isSameDay(start, end) && !template) {\n    const [firstM, secondM] = dropSame(dates, 'a', true);\n    return `${format(start, 'ddd')} ${formatHour(\n      start\n    )}${firstM} – ${formatHour(end)}${secondM}`;\n  }\n\n  const formatTemplate = 'ddd h:mma';\n  const startDateStr = format(start, template || formatTemplate);\n  const endDateStr = format(end, template2 || formatTemplate);\n\n  return `${startDateStr} – ${endDateStr}`;\n};\n","import classcat from 'classcat';\nimport { format } from 'date-fns';\nimport invariant from 'invariant';\nimport Resizable, { ResizeCallback } from 're-resizable';\nimport React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState\n} from 'react';\nimport Draggable, { DraggableEventHandler } from 'react-draggable';\nimport useMousetrap from '../hooks/useMousetrap';\nimport { CellInfo } from '../types';\nimport { ScheduleProps } from './Schedule';\nimport { getTextForDateRange } from '../utils/getTextForDateRange';\n// @ts-ignore\nimport VisuallyHidden from '@reach/visually-hidden';\n\nexport const RangeBox = React.memo(function RangeBox({\n  classes,\n  grid,\n  isBeingEdited,\n  rangeIndex,\n  cellIndex,\n  cellArray,\n  cell,\n  className,\n  onChange,\n  cellInfoToDateRange,\n  isResizable,\n  isDeletable,\n  moveAxis,\n  onActiveChange\n}: ScheduleProps & {\n  cellIndex: number;\n  cellArray: CellInfo[];\n  className?: string;\n  rangeIndex: number;\n  cell: CellInfo;\n}) {\n  const ref = useRef(null);\n  const [modifiedCell, setModifiedCell] = useState(cell);\n  const originalRect = useMemo(() => grid.getRectFromCell(cell), [cell, grid]);\n  const rect = useMemo(() => grid.getRectFromCell(modifiedCell), [\n    modifiedCell,\n    grid\n  ]);\n\n  useEffect(() => {\n    setModifiedCell(cell);\n  }, [cell]);\n\n  const modifiedDateRange = useMemo(() => cellInfoToDateRange(modifiedCell), [\n    modifiedCell\n  ]);\n\n  const handleDelete = useCallback(() => {\n    if (!isDeletable) {\n      return;\n    }\n\n    onChange && onChange(undefined, rangeIndex);\n  }, [ref.current, onChange, isDeletable, rangeIndex]);\n\n  useMousetrap('del', handleDelete, ref.current);\n\n  const { top, left, width, height } = rect;\n\n  const isStart = cellIndex === 0;\n  const isEnd = cellIndex === cellArray.length - 1;\n\n  const handleStop = useCallback(() => {\n    onChange && onChange(cellInfoToDateRange(modifiedCell), rangeIndex);\n  }, [modifiedCell, rangeIndex, cellInfoToDateRange, onChange]);\n\n  useMousetrap(\n    'up',\n    () => {\n      if (moveAxis === 'none' || moveAxis === 'x') {\n        return;\n      }\n\n      if (modifiedCell.startY === 0) {\n        return;\n      }\n\n      const newCell = {\n        ...modifiedCell,\n        startY: modifiedCell.startY - 1,\n        endY: modifiedCell.endY - 1\n      };\n\n      onChange && onChange(cellInfoToDateRange(newCell), rangeIndex);\n    },\n    ref.current\n  );\n\n  useMousetrap(\n    'down',\n    () => {\n      if (moveAxis === 'none' || moveAxis === 'x') {\n        return;\n      }\n\n      if (modifiedCell.endY === grid.numVerticalCells - 1) {\n        return;\n      }\n\n      const newCell = {\n        ...modifiedCell,\n        startY: modifiedCell.startY + 1,\n        endY: modifiedCell.endY + 1\n      };\n\n      onChange && onChange(cellInfoToDateRange(newCell), rangeIndex);\n    },\n    ref.current\n  );\n\n  const handleDrag: DraggableEventHandler = useCallback(\n    (event, { y, x }) => {\n      if (moveAxis === 'none') {\n        return;\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n\n      const newRect = {\n        ...rect\n      };\n\n      if (moveAxis === 'both' || moveAxis === 'y') {\n        const _startY = y;\n        const _endY = _startY + rect.height;\n        const newTop = Math.min(_startY, _endY);\n        const newBottom = newTop + rect.height;\n        newRect.bottom = newBottom;\n        newRect.top = newTop;\n      }\n\n      if (moveAxis === 'both' || moveAxis === 'x') {\n        const _startX = x;\n        const _endX = _startX + rect.width;\n        const newLeft = Math.min(_startX, _endX);\n        const newRight = newLeft + rect.width;\n        newRect.right = newRight;\n        newRect.left = newLeft;\n      }\n\n      const { startY, startX } = grid.getCellFromRect(newRect);\n\n      const newCell = {\n        ...cell,\n        startX,\n        endX: startX + cell.spanX - 1,\n        startY,\n        endY: startY + cell.spanY - 1\n      };\n\n      invariant(\n        newCell.spanY === cell.spanY && newCell.spanX === cell.spanX,\n        `Expected the dragged time cell to have the same dimensions)`\n      );\n\n      setModifiedCell(newCell);\n    },\n    [grid, rect, moveAxis, setModifiedCell]\n  );\n\n  const handleResize: ResizeCallback = useCallback(\n    (event, direction, _ref, delta) => {\n      if (!isResizable) {\n        return;\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n\n      if (delta.height === 0) {\n        return;\n      }\n\n      const newSize = {\n        height: delta.height + rect.height,\n        width: delta.width + rect.width + 20\n      };\n\n      const newRect = {\n        ...originalRect,\n        ...newSize\n      };\n\n      if (direction.includes('top')) {\n        newRect.top -= delta.height;\n      } else if (direction.includes('bottom')) {\n        newRect.bottom += delta.height;\n      }\n\n      const { spanY, startY, endY } = grid.getCellFromRect(newRect);\n      const newCell = {\n        ...cell,\n        spanY,\n        startY,\n        endY\n      };\n\n      setModifiedCell(newCell);\n    },\n    [grid, rect, isResizable, setModifiedCell, originalRect]\n  );\n\n  const handleOnFocus = useCallback(() => {\n    onActiveChange && onActiveChange(rangeIndex, cellIndex);\n  }, [onActiveChange]);\n\n  const handleOnBlur = useCallback(() => {\n    onActiveChange && onActiveChange(rangeIndex, null);\n  }, [onActiveChange]);\n\n  return (\n    <Draggable\n      axis={moveAxis}\n      bounds={{\n        top: 0,\n        bottom: grid.totalHeight - height,\n        left: 0,\n        right: grid.totalWidth\n      }}\n      position={{ x: left, y: top }}\n      onDrag={handleDrag}\n      onStop={handleStop}\n      cancel={`.${classes.handle}`}\n    >\n      <button\n        onFocus={handleOnFocus}\n        onBlur={handleOnBlur}\n        className={classcat([\n          classes['event'],\n          classes['button-reset'],\n          classes['range-box'],\n          className,\n          {\n            [classes['is-draggable']]: moveAxis !== 'none',\n            [classes['is-being-edited']]: isBeingEdited && isBeingEdited(cell)\n          }\n        ])}\n        ref={ref}\n        tabIndex={0}\n        style={{ width: width - 20, height }}\n      >\n        <Resizable\n          size={{ ...originalRect, width: originalRect.width - 20 }}\n          onResize={handleResize}\n          onResizeStop={handleStop}\n          handleWrapperClass={classes['handle-wrapper']}\n          enable={\n            isResizable\n              ? {\n                  top: true,\n                  bottom: true\n                }\n              : {}\n          }\n          handleClasses={{\n            bottom: classcat([classes['handle'], classes.bottom]),\n            bottomLeft: classcat([classes['handle'], classes['bottom-left']]),\n            bottomRight: classcat([classes['handle'], classes['bottom-right']]),\n            left: classcat([classes['handle'], classes.left]),\n            right: classcat([classes['handle'], classes.right]),\n            top: classcat([classes['handle'], classes.top]),\n            topLeft: classcat([classes['handle'], classes['top-left']]),\n            topRight: classcat([classes['handle'], classes['top-right']])\n          }}\n        >\n          <div style={{ width, height }} className={classes['event-content']}>\n            <VisuallyHidden>\n              {getTextForDateRange(modifiedDateRange)}\n            </VisuallyHidden>\n            <span aria-hidden className={classes['start']}>\n              {isStart && format(modifiedDateRange[0], 'h:mma')}\n            </span>\n            <span aria-hidden className={classes['end']}>\n              {isEnd && format(modifiedDateRange[1], 'h:mma')}\n            </span>\n          </div>\n        </Resizable>\n      </button>\n    </Draggable>\n  );\n});\n","import React from 'react';\nimport { CellInfo, DateRange, Event, Grid, OnChangeCallback } from '../types';\nimport { RangeBox } from './RangeBox';\n\nexport type ScheduleProps = {\n  classes: Record<string, string>;\n  grid: Grid;\n  onChange?: OnChangeCallback;\n  isResizable?: boolean;\n  isDeletable?: boolean;\n  moveAxis: 'none' | 'both' | 'x' | 'y';\n  isBeingEdited?(cell: CellInfo): boolean;\n  cellInfoToDateRange(cell: CellInfo): DateRange;\n  onActiveChange?(...args: [number, number] | [number, null]): void;\n};\n\nexport const Schedule = React.memo(function Schedule({\n  classes,\n  ranges,\n  grid,\n  className,\n  onChange,\n  isResizable,\n  isDeletable,\n  moveAxis: isMovable,\n  cellInfoToDateRange,\n  dateRangeToCells,\n  isBeingEdited,\n  onActiveChange: onActive\n}: {\n  dateRangeToCells(range: DateRange): CellInfo[];\n  ranges: Event;\n  className?: string;\n  classes: Record<string, string>;\n} & ScheduleProps) {\n  return (\n    <div className={classes['range-boxes']}>\n      {ranges.map((dateRange, rangeIndex) => {\n        return (\n          <span key={rangeIndex}>\n            {dateRangeToCells(dateRange).map((cell, cellIndex, array) => {\n              return (\n                <RangeBox\n                  classes={classes}\n                  onActiveChange={onActive}\n                  key={cellIndex}\n                  isResizable={isResizable}\n                  moveAxis={isMovable}\n                  isDeletable={isDeletable}\n                  cellInfoToDateRange={cellInfoToDateRange}\n                  cellArray={array}\n                  cellIndex={cellIndex}\n                  rangeIndex={rangeIndex}\n                  className={className}\n                  isBeingEdited={isBeingEdited}\n                  onChange={onChange}\n                  grid={grid}\n                  cell={cell}\n                />\n              );\n            })}\n          </span>\n        );\n      })}\n    </div>\n  );\n});\n","import useComponentSize from '@rehooks/component-size';\nimport classcat from 'classcat';\nimport { addDays, format, isEqual } from 'date-fns';\nimport invariant from 'invariant';\nimport { times } from 'lodash';\nimport React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState\n} from 'react';\nimport 'resize-observer-polyfill/dist/ResizeObserver.global';\nimport scrollIntoView from 'scroll-into-view-if-needed';\nimport useUndo from 'use-undo';\nimport { useClickAndDrag } from '../hooks/useClickAndDrag';\nimport useMousetrap from '../hooks/useMousetrap';\nimport { useStickyStyle } from '../hooks/useStickyStyle';\nimport {\n  CellInfo,\n  DateRange,\n  Event as CalendarEvent,\n  Grid,\n  OnChangeCallback\n} from '../types';\nimport { createGrid } from '../utils/createGrid';\nimport { createMapCellInfoToContiguousDateRange } from '../utils/createMapCellInfoToContiguousDateRange';\nimport {\n  createMapCellInfoToRecurringTimeRange,\n  RecurringTimeRange\n} from '../utils/createMapCellInfoToRecurringTimeRange';\nimport { createMapDateRangeToCells } from '../utils/createMapDateRangeToCells';\nimport { mergeEvents, mergeRanges } from '../utils/mergeEvents';\nimport { Cell } from './Cell';\nimport { Schedule } from './Schedule';\n\nconst MINS_IN_DAY = 24 * 60;\nconst horizontalPrecision = 1;\nconst toDay = (x: number) => x * horizontalPrecision;\nconst toX = (days: number) => days / horizontalPrecision;\n\nexport const TimeGridScheduler = React.memo(function TimeGridScheduler({\n  verticalPrecision = 30,\n  visualGridVerticalPrecision = 30,\n  schedule,\n  originDate = new Date(),\n  classes\n}: {\n  originDate?: Date;\n  verticalPrecision?: number;\n  visualGridVerticalPrecision?: number;\n  schedule: CalendarEvent;\n  classes: Record<string, string>;\n}) {\n  const numVerticalCells = MINS_IN_DAY / verticalPrecision;\n  const numHorizontalCells = 7 / horizontalPrecision;\n  const toMin = useCallback((y: number) => y * verticalPrecision, [\n    verticalPrecision\n  ]);\n  const toY = (mins: number) => mins / verticalPrecision;\n\n  const cellInfoToDateRanges = useMemo(\n    () =>\n      createMapCellInfoToRecurringTimeRange({\n        originDate,\n        fromY: toMin,\n        fromX: toDay\n      }),\n    [toMin, toDay, originDate]\n  );\n\n  const cellInfoToSingleDateRange = useCallback(\n    (cell: CellInfo): DateRange => {\n      const [first, ...rest] = cellInfoToDateRanges(cell);\n      invariant(\n        rest.length === 0,\n        `Expected \"cellInfoToSingleDateRange\" to return a single date range, found ${\n          rest.length\n        } additional ranges instead. This is a bug in @remotelock/weekly-scheduler`\n      );\n\n      return first;\n    },\n    [cellInfoToDateRanges]\n  );\n\n  const dateRangeToCells = useMemo(\n    () =>\n      createMapDateRangeToCells({\n        originDate,\n        numVerticalCells,\n        numHorizontalCells,\n        toX,\n        toY\n      }),\n    [toY, toX, numVerticalCells, numHorizontalCells, originDate]\n  );\n\n  const root = useRef<HTMLDivElement | null>(null);\n  const parent = useRef<HTMLDivElement | null>(null);\n  const timelineStickyStyle = useStickyStyle(root, { top: false, left: true });\n  const headerStickyStyle = useStickyStyle(root, { top: false, left: false });\n\n  const size = useComponentSize(parent);\n  const {\n    style,\n    box,\n    isDragging,\n    hasFinishedDragging,\n    cancel\n  } = useClickAndDrag(parent);\n  const [\n    pendingCreation,\n    setPendingCreation\n  ] = useState<RecurringTimeRange | null>(null);\n  const [\n    scheduleState,\n    {\n      set: setSchedule,\n      undo: undoSchedule,\n      redo: redoSchedule,\n      canUndo: canUndoSchedule,\n      canRedo: canRedoSchedule\n    }\n  ] = useUndo<CalendarEvent>(schedule);\n\n  const { totalHeight, totalWidth } = useMemo(() => {\n    let totalHeight: number | null = null;\n    let totalWidth: number | null = null;\n    if (parent.current !== null) {\n      ({ scrollHeight: totalHeight, scrollWidth: totalWidth } = parent.current);\n    }\n\n    return { totalHeight, totalWidth };\n  }, [parent.current, size]);\n\n  const grid = useMemo<Grid | null>(() => {\n    if (totalHeight === null || totalWidth === null) {\n      return null;\n    }\n\n    return createGrid({\n      totalHeight,\n      totalWidth,\n      numHorizontalCells,\n      numVerticalCells\n    });\n  }, [totalHeight, totalWidth, numHorizontalCells, numVerticalCells]);\n\n  useEffect(() => {\n    if (grid === null || box === null) {\n      setPendingCreation(null);\n      return;\n    }\n\n    const constrainedBox = box;\n    const cell = grid.getCellFromRect(constrainedBox);\n    const dateRanges = cellInfoToDateRanges(cell);\n    const event = dateRanges;\n    setPendingCreation(event);\n  }, [box, grid, setPendingCreation]);\n\n  useEffect(() => {\n    if (hasFinishedDragging) {\n      setSchedule(mergeEvents(scheduleState.present, pendingCreation));\n      setPendingCreation(null);\n    }\n  }, [\n    hasFinishedDragging,\n    setSchedule,\n    setPendingCreation,\n    pendingCreation,\n    scheduleState.present\n  ]);\n\n  useMousetrap(\n    'ctrl+z',\n    () => {\n      if (!canUndoSchedule) {\n        return;\n      }\n\n      undoSchedule();\n    },\n    document\n  );\n\n  useMousetrap(\n    'ctrl+shift+z',\n    () => {\n      if (!canRedoSchedule) {\n        return;\n      }\n\n      redoSchedule();\n    },\n    document\n  );\n\n  useMousetrap(\n    'esc',\n    () => {\n      if (pendingCreation) {\n        cancel();\n      }\n    },\n    document\n  );\n\n  useEffect(() => {\n    cancel();\n  }, [size]);\n\n  const handleEventChange = useCallback<OnChangeCallback>(\n    (newDateRange, rangeIndex) => {\n      if (!scheduleState.present && newDateRange) {\n        return [newDateRange];\n      }\n\n      let newSchedule = [...scheduleState.present];\n\n      if (!newDateRange) {\n        newSchedule.splice(rangeIndex, 1);\n      } else {\n        if (\n          isEqual(newDateRange[0], newSchedule[rangeIndex][0]) &&\n          isEqual(newDateRange[1], newSchedule[rangeIndex][1])\n        ) {\n          return;\n        }\n        newSchedule[rangeIndex] = newDateRange;\n      }\n\n      newSchedule = mergeRanges(newSchedule);\n\n      setSchedule(newSchedule);\n    },\n    [scheduleState.present]\n  );\n\n  const getDateRangeForVisualGrid = useMemo(\n    () =>\n      createMapCellInfoToContiguousDateRange({\n        originDate,\n        fromX: toDay,\n        fromY: y => y * visualGridVerticalPrecision\n      }),\n    [visualGridVerticalPrecision, toDay, originDate]\n  );\n\n  useEffect(() => {\n    if (!document.activeElement) {\n      return;\n    }\n\n    if (!root.current || !root.current.contains(document.activeElement)) {\n      return;\n    }\n\n    scrollIntoView(document.activeElement, {\n      scrollMode: 'if-needed',\n      block: 'nearest',\n      inline: 'nearest'\n    });\n  }, [root.current, scheduleState.present]);\n\n  const numVisualVerticalCells = (24 * 60) / visualGridVerticalPrecision;\n\n  return (\n    <>\n      <button disabled={!canUndoSchedule} onClick={undoSchedule}>\n        Undo\n      </button>\n      <button disabled={!canRedoSchedule} onClick={redoSchedule}>\n        Redo\n      </button>\n      <div\n        ref={root}\n        className={classcat([\n          classes['root'],\n          { [classes['no-scroll']]: isDragging }\n        ])}\n      >\n        <div\n          style={timelineStickyStyle}\n          aria-hidden\n          className={classes['timeline']}\n        >\n          <div className={classes['header']}>\n            <div className={classes['day-column']}>\n              <div className={classcat([classes['cell'], classes.title])}>\n                T\n              </div>\n            </div>\n          </div>\n          <div className={classes['calendar']}>\n            <div className={classes['day-column']}>\n              <div className={classes['day-hours']}>\n                {times(numVisualVerticalCells).map(timeIndex => {\n                  return (\n                    <Cell\n                      classes={classes}\n                      getDateRangeForVisualGrid={getDateRangeForVisualGrid}\n                      key={timeIndex}\n                      timeIndex={timeIndex}\n                    >\n                      {({ start, isHourStart }) => {\n                        if (isHourStart) {\n                          return (\n                            <div className={classes['time']}>\n                              {format(start, 'h a')}\n                            </div>\n                          );\n                        }\n\n                        return null;\n                      }}\n                    </Cell>\n                  );\n                })}\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <div>\n          <div\n            style={headerStickyStyle}\n            role=\"presentation\"\n            className={classcat([classes['calendar'], classes.header])}\n          >\n            {times(7).map(i => (\n              <div\n                key={i}\n                role=\"presentation\"\n                className={classes['day-column']}\n              >\n                <div className={classcat([classes['cell'], classes.title])}>\n                  {format(addDays(originDate, i), 'ddd')}\n                </div>\n              </div>\n            ))}\n          </div>\n          <div className={classes['layer-container']}>\n            {isDragging && (\n              <div className={classes['drag-box']} style={style}>\n                {hasFinishedDragging && <div className={classes['popup']} />}\n              </div>\n            )}\n            {grid && pendingCreation && isDragging && (\n              <Schedule\n                classes={classes}\n                dateRangeToCells={dateRangeToCells}\n                cellInfoToDateRange={cellInfoToSingleDateRange}\n                className={classes['is-pending-creation']}\n                ranges={mergeEvents(scheduleState.present, pendingCreation)}\n                grid={grid}\n                moveAxis=\"none\"\n              />\n            )}\n            {grid && !pendingCreation && (\n              <Schedule\n                classes={classes}\n                dateRangeToCells={dateRangeToCells}\n                cellInfoToDateRange={cellInfoToSingleDateRange}\n                isResizable\n                moveAxis=\"y\"\n                isDeletable\n                onChange={handleEventChange}\n                ranges={scheduleState.present}\n                grid={grid}\n              />\n            )}\n\n            <div ref={parent} role=\"grid\" className={classes['calendar']}>\n              {times(7).map(dayIndex => {\n                return (\n                  <div\n                    role=\"gridcell\"\n                    key={dayIndex}\n                    className={classes['day-column']}\n                  >\n                    <div className={classes['day-hours']}>\n                      {times(numVisualVerticalCells).map(timeIndex => {\n                        return (\n                          <Cell\n                            classes={classes}\n                            getDateRangeForVisualGrid={\n                              getDateRangeForVisualGrid\n                            }\n                            key={timeIndex}\n                            timeIndex={timeIndex}\n                          />\n                        );\n                      })}\n                    </div>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        </div>\n      </div>\n    </>\n  );\n});\n","import { DateRange, MapCellInfoToDateRange } from '../types';\nimport { range } from 'lodash';\nimport {\n  addMinutes,\n  isBefore,\n  endOfDay,\n  isEqual,\n  subDays,\n  startOfDay,\n  compareAsc\n} from 'date-fns';\nimport { cellToDate } from './cellToDate';\n\nexport type RecurringTimeRange = DateRange[];\n\nexport const createMapCellInfoToRecurringTimeRange: MapCellInfoToDateRange = ({\n  fromY: toMin,\n  fromX: toDay,\n  originDate\n}) => ({ startX, startY, endX, spanY }) => {\n  const result = range(startX, endX + 1)\n    .map(i => {\n      const startDate = cellToDate({\n        startX: i,\n        startY,\n        toMin,\n        toDay,\n        originDate\n      });\n      let endDate = addMinutes(startDate, toMin(spanY));\n\n      if (isEqual(endDate, startOfDay(endDate))) {\n        endDate = endOfDay(subDays(endDate, 1));\n      }\n\n      const range: DateRange = isBefore(startDate, endDate)\n        ? [startDate, endDate]\n        : [endDate, startDate];\n\n      return range;\n    })\n    .sort((range1, range2) => compareAsc(range1[0], range2[0]));\n\n  return result;\n};\n","import { DateRange, CellInfo } from '../types';\nimport {\n  startOfDay,\n  differenceInDays,\n  differenceInMinutes,\n  isEqual\n} from 'date-fns';\nimport { range } from 'lodash';\nimport { getSpan } from './getSpan';\n\nexport const createMapDateRangeToCells = ({\n  toX = (x: number) => x,\n  toY,\n  numVerticalCells,\n  originDate\n}: {\n  toX: (day: number) => number;\n  toY: (min: number) => number;\n  numHorizontalCells: number;\n  numVerticalCells: number;\n  originDate: Date;\n}) => ([start, end]: DateRange): CellInfo[] => {\n  const originOfThisDay = startOfDay(start);\n  const _startX = toX(differenceInDays(start, originDate));\n  const _startY = toY(differenceInMinutes(start, originOfThisDay));\n  const _endX = toX(differenceInDays(end, originDate));\n  const _endY = toY(differenceInMinutes(end, startOfDay(end))) - 1;\n\n  const cells = range(_startX, _endX + 1).map(i => {\n    const startX = i;\n    const endX = i;\n    const atStart = i === _startX;\n    const atEnd = i === _endX;\n    const startY = !atStart ? 0 : _startY;\n    const endY = !atEnd ? numVerticalCells - 1 : _endY;\n    const spanX = getSpan(startX, endX);\n    const spanY = getSpan(startY, endY);\n\n    return {\n      startX,\n      startY,\n      endX,\n      endY,\n      spanX,\n      spanY\n    };\n  });\n\n  if (isEqual(end, startOfDay(end))) {\n    cells.pop();\n  }\n\n  return cells;\n};\n","import { Grid, CellInfo, Rect } from '../types';\nimport { clamp, floor, round } from 'lodash';\nimport { getSpan } from './getSpan';\n\nexport const createGrid = ({\n  totalHeight,\n  totalWidth,\n  numVerticalCells,\n  numHorizontalCells\n}: {\n  totalHeight: number;\n  totalWidth: number;\n  numVerticalCells: number;\n  numHorizontalCells: number;\n}): Grid => {\n  const cellHeight = floor(totalHeight / numVerticalCells);\n  const cellWidth = floor(totalWidth / numHorizontalCells);\n\n  return {\n    totalHeight,\n    totalWidth,\n    numVerticalCells,\n    numHorizontalCells,\n    cellWidth,\n    cellHeight,\n\n    getRectFromCell(data: CellInfo) {\n      const { endX, startX, endY, startY, spanX, spanY } = data;\n      const bottom = endY * this.cellHeight;\n      const top = startY * this.cellHeight;\n      const left = startX * this.cellWidth;\n      const right = endX * this.cellWidth;\n      const height = spanY * this.cellHeight;\n      const width = spanX * this.cellWidth;\n\n      return {\n        bottom,\n        top,\n        left,\n        right,\n        height,\n        width,\n\n        // @TODO: check the math\n        startX: startX * this.cellWidth,\n        endX: endX * this.cellWidth,\n        startY: startY * this.cellHeight,\n        endY: endY * this.cellHeight\n      };\n    },\n\n    getCellFromRect(data: Rect) {\n      const startX = clamp(\n        floor(data.left / this.cellWidth),\n        0,\n        numHorizontalCells - 1\n      );\n      const startY = clamp(\n        round(data.top / this.cellHeight),\n        0,\n        numVerticalCells - 1\n      );\n      const endX = clamp(\n        floor(data.right / this.cellWidth),\n        0,\n        numHorizontalCells - 1\n      );\n      const endY = clamp(\n        round(data.bottom / this.cellHeight),\n        0,\n        numVerticalCells - 1\n      );\n      const spanX = clamp(getSpan(startX, endX), 1, numHorizontalCells);\n      const spanY = clamp(getSpan(startY, endY), 1, numVerticalCells);\n\n      return {\n        spanX,\n        spanY,\n        startX,\n        startY,\n        endX,\n        endY\n      };\n    }\n  };\n};\n","import { MapCellInfoToDateRange } from '../types';\nimport { isBefore } from 'date-fns';\nimport { cellToDate } from './cellToDate';\n\nexport const createMapCellInfoToContiguousDateRange: MapCellInfoToDateRange = ({\n  fromY: toMin,\n  fromX: toDay,\n  originDate\n}) => ({ startX, startY, endX, endY }) => {\n  const startDate = cellToDate({ startX, startY, toMin, toDay, originDate });\n  const endDate = cellToDate({\n    startX: endX,\n    startY: endY,\n    toMin,\n    toDay,\n    originDate\n  });\n\n  return [\n    isBefore(startDate, endDate) ? [startDate, endDate] : [endDate, startDate]\n  ];\n};\n","import { compareAsc, startOfWeek } from 'date-fns';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'resize-observer-polyfill/dist/ResizeObserver.global';\nimport { Event as CalendarEvent } from './types';\n\nimport { TimeGridScheduler } from './components/TimeGridScheduler';\nimport classes from './styles.module.scss';\n\nconst rangeStrings: [string, string][] = [\n  ['2019-03-03T22:45:00.000Z', '2019-03-04T01:15:00.000Z'],\n  ['2019-03-05T22:00:00.000Z', '2019-03-06T01:00:00.000Z'],\n  ['2019-03-04T22:15:00.000Z', '2019-03-05T01:00:00.000Z'],\n  ['2019-03-07T05:30:00.000Z', '2019-03-07T10:00:00.000Z'],\n  ['2019-03-08T22:00:00.000Z', '2019-03-09T01:00:00.000Z'],\n  ['2019-03-09T22:00:00.000Z', '2019-03-10T01:00:00.000Z'],\n  ['2019-03-06T22:00:00.000Z', '2019-03-07T01:00:00.000Z']\n];\n\nconst defaultSchedule: CalendarEvent = rangeStrings\n  .map(range => range.map(dateString => new Date(dateString)) as [Date, Date])\n  .sort((range1, range2) => compareAsc(range1[0], range2[0]));\n\nconst rootElement = document.getElementById('root');\n\nReactDOM.render(\n  <TimeGridScheduler\n    classes={classes}\n    originDate={startOfWeek(new Date('2019-03-04'), { weekStartsOn: 1 })}\n    schedule={defaultSchedule}\n    verticalPrecision={15}\n  />,\n  rootElement\n);\n"],"sourceRoot":""}